<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zyyiszyy.github.io</id>
    <title>zyyire</title>
    <updated>2021-06-08T15:51:01.259Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zyyiszyy.github.io"/>
    <link rel="self" href="https://zyyiszyy.github.io/atom.xml"/>
    <subtitle>破碎吧现实，崩裂吧精神，放逐这个世界！</subtitle>
    <logo>https://zyyiszyy.github.io/images/avatar.png</logo>
    <icon>https://zyyiszyy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zyyire</rights>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2021初夏赛部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/cumtctf2021-chu-xia-sai-bu-fen-wp/</id>
        <link href="https://zyyiszyy.github.io/post/cumtctf2021-chu-xia-sai-bu-fen-wp/">
        </link>
        <updated>2021-06-08T15:09:45.000Z</updated>
        <content type="html"><![CDATA[<p>这次re题目做了6道，pwn做了3道。马上大四了，这算是最后一次打校赛了，遗憾的是最后pwn能力也没提上来，以前一直想着能把re和pwn都打的差不多，独担队伍大旗，怪我一直搁置pwn了，导致我二进制就是个半吊子，哪个二进制手不会做点pwn题呢。不过就算没机会打校赛了，我也下定决心搞pwn了，从0day安全看起，加油！<br>
<img src="https://zyyiszyy.github.io/post-images/1623167429152.png" alt="" loading="lazy"></p>
<h1 id="图标好奇怪">图标好奇怪</h1>
<p>看图标是python编译出来的exe文件，这道题考察的是pythonexe反编译拿到源代码，先用pyinstxtractor反编译文件，拿到一个文件夹，同时发现编译类型是python3.7版本的，接下来要用到：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165169112.png" alt="" loading="lazy"><br>
从文件夹中找到111文件，改后缀pyc，这个其实就是python字节码文件，用hex工具打开：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165202162.png" alt="" loading="lazy"><br>
发现开头是E3 00，这是因为这样转换会丢失python magic numbers，我之前总结了几个常用版本的魔法数：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165237433.png" alt="" loading="lazy"><br>
这次用3.7的，加上之后如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165247133.png" alt="" loading="lazy"><br>
然后用uncompyle6反编译成源码，就会编译成功，查看源码：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165286384.png" alt="" loading="lazy"><br>
倒不是很难，就是先判断异或128，127后这些字符的取值范围，在写反向脚本时添加一些条件判断即可，这里我为了节省时间，一开始大致判断范围，发现有一些字符乱码或明显不对我就单独加对应的条件：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165339369.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165366915.png" alt="" loading="lazy"></p>
<h1 id="有些奇怪的exe">有些奇怪的exe</h1>
<p>先查看文件类型，有壳的脱壳，然后对应ida打开：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165409139.png" alt="" loading="lazy"><br>
这个主要就是逆算法，没什么拐弯的，前面for是大小写交换，非字母不变，下面就是涉及一个中间变量，我这里直接爆破的，节约思考时间，直接上脚本：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165419515.png" alt="" loading="lazy"></p>
<h1 id="ezcreak">ezCreak</h1>
<p>先运行一下查看程序功能：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165470380.png" alt="" loading="lazy"><br>
输入flag，错误直接退出，没有错误提示，暂时不知道有无正确提示。直接ida32打开什么也看不出来，字符串也没有有用信息：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165478656.png" alt="" loading="lazy"><br>
怀疑加壳或者某种保护，可能运行时自解密，用od打开，查看字符串，发现有信息，应该是正确提示：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165540437.png" alt="" loading="lazy"><br>
f9运行一下试试，发现停在一个地方程序中断，怀疑这里就是解密后的程序：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165546027.png" alt="" loading="lazy"><br>
dump下来，用ida分析：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165576052.png" alt="" loading="lazy"><br>
找到如下关键函数，主要逻辑应该是在do循环那里，有一个byte数组，但是静态分析找不到数组内容：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165581753.png" alt="" loading="lazy"><br>
再次用x32dbg打开，输入假flag后在图示下断点：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165620233.png" alt="" loading="lazy"><br>
看寄存器内容，找到[ecx+eax]内存的值，如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165632339.png" alt="" loading="lazy"><br>
接下来就可以写脚本了，注意的是下面是小端序记法，需要改一下顺序：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165662068.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1623165676593.png" alt="" loading="lazy"></p>
<h1 id="ezmath">ezMath</h1>
<p>ida打开找有用信息，主要在两个函数里：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165774753.png" alt="" loading="lazy"><br>
分别打开对应函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165785324.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1623165808859.png" alt="" loading="lazy"><br>
有点绕，主要得看清判断界限，提前写清范围就不太容易搞混了，总结得到的信息如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165827130.png" alt="" loading="lazy"><br>
自己做卡了好久，最终由一个队友想到的杨辉三角形，太久没接触都忘了，这道题简单难度，如果看出来了很容易，看不出来就难办了......<br>
<img src="https://zyyiszyy.github.io/post-images/1623165923924.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1623165943775.png" alt="" loading="lazy"></p>
<h1 id="ezmaze">ezMaze</h1>
<p>先运行一下看下程序什么样子：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165973693.png" alt="" loading="lazy"><br>
正如名字迷宫，ida打开，查看字符串：<br>
<img src="https://zyyiszyy.github.io/post-images/1623165984652.png" alt="" loading="lazy"><br>
有些乱码，并且有些语句反编译错误，我们尽可能分析，上面一大堆函数我们猜测是构建迷宫：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166010374.png" alt="" loading="lazy"><br>
静态分析不行就动态分析，用x64dbg打开，查看生成迷宫代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166022335.png" alt="" loading="lazy"><br>
验证了我们的猜想，发现自动注释有很多o0，但这里不能得到我们的迷宫，它一定生成了迷宫但是放在了一个地方存储，我们在栈里找，很容易找到迷宫：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166050676.png" alt="" loading="lazy"><br>
我们将其导出来，放在文本文件里方便分析，要注意的是，因为生成迷宫代码运行了14次，所以迷宫很可能是14行，稍加整理，迷宫如下：</p>
<pre><code>\#ooo000ooo0000
000ooooo000000
000o0000000000
000o0000000000
000ooooooo0000
o00000000o0000
o00000000o0000
oooooooooo0000
00000000o00o00
00000000o00o00
0000ooooo00o00
0000o000000o00
0000oooooooo00
00000000000000
</code></pre>
<p>又从x64dbg中看到下图，发现迷宫是wsad走的：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166209037.png" alt="" loading="lazy"><br>
又如图提示加上cumtctf{}，所以可以得到flag。<br>
<img src="https://zyyiszyy.github.io/post-images/1623166226433.png" alt="" loading="lazy"></p>
<h1 id="神奇的编码">神奇的编码</h1>
<p>先翻译字节码，写出正向算法的脚本，如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166260968.png" alt="" loading="lazy"><br>
流程大概是先输入flag，再按位和255异或，然后以字节形式排开循环左移一个16进制位，再按字节分开重新组合成字节数组，base64加密和已知列表比较，若相同就是真的flag，否则反之，解密的话就按顺序逆过来，求逆简单但难在编码转换上，一个utf-8编码卡了我一天多的时间：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166266839.png" alt="" loading="lazy"><br>
如图所示，需要b64解码之后再utf-8解码为字符串，然后再继续解密流程，否则出来的并非真的flag，而是大多数是两位代表一位flag的形式，就是因为一开始没有utf-8解码，完整解密脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166294221.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166307725.png" alt="" loading="lazy"></p>
<h1 id="pwn1">pwn1</h1>
<p>ida打开，逻辑如下，先输入个字符，没判断输入长度，然后下面有个v5决定出不出shell：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166344512.png" alt="" loading="lazy"><br>
查看栈分布，只需要覆盖v5，使之变成2021：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166353220.png" alt="" loading="lazy"><br>
脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166472711.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166484785.png" alt="" loading="lazy"></p>
<h1 id="pwn2">pwn2</h1>
<p>ida打开，发现 Fmtstr字符串，这是个格式化字符串构造payload的工具：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166522535.png" alt="" loading="lazy"><br>
用法如下：<br>
fmtstrpayload(offset, writes, numbwritten=0, writesize='byte')<br>
第一个参数表示格式化字符串的偏移；<br>
第二个参数表示需要利用%n写入的数据，采用字典形式，写成{GOT: systemAddress}。<br>
第三个参数表示已经输出的字符个数，这里没有，为0，采用默认值即可；<br>
第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。<br>
先输入：aaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p泄露格式化字符串的偏移：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166537064.png" alt="" loading="lazy"><br>
得到偏移是5，找get函数在got plt的位置：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166560344.png" alt="" loading="lazy"><br>
/bin/shell的地址如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166569274.png" alt="" loading="lazy"><br>
我们的思路是第一个get输入payload，将binshell地址替换到getGOT的地址，然后二次调用get就是执行我们的binshell，写脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166595038.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166600184.png" alt="" loading="lazy"></p>
<h1 id="pwn3">pwn3</h1>
<p>查看程序保护情况：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166636435.png" alt="" loading="lazy"><br>
ida打开发现如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166641273.png" alt="" loading="lazy"><br>
再看一下generate函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166662865.png" alt="" loading="lazy"><br>
这个先计算passwd，赋值为一个随机数，再在主函数用它和输入作比较，相等就输出flag。这里重点在于linux下的strcmp实现方式，查了下strcmp glibc里的实现：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166671098.png" alt="" loading="lazy"><br>
这里retuen的是c1-c2，我们程序中输入为c1，随机字符串为c2，所以strcmp里先进入循环判断c1是否为空，是的话就返回c1-c2，c2后面的字节就截断不判断了，所以值判断了一个字节，我们只需要输入空字节，1/256概率等随机第一个字节也为空字节就可以输出flag了。<br>
脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166687983.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1623166705585.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2021新春赛部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/cumtctf2021-xin-chun-sai-bu-fen-wp/</id>
        <link href="https://zyyiszyy.github.io/post/cumtctf2021-xin-chun-sai-bu-fen-wp/">
        </link>
        <updated>2021-03-30T15:11:48.000Z</updated>
        <content type="html"><![CDATA[<p>这次比赛re题目一共6道做了5道，拿了4个一血一个2血。这次题目学弟出的比较简单，并且一些大佬要复习考研就没参加，我才能拿几个一血，总体还行吧，也算认真打了。这次比赛接触了RISC-V架构、RISC精简指令集和intel 128位拓展指令，并且接触了一个新的工具ghidra。</p>
<h1 id="rookie">Rookie</h1>
<p>64位ida打开，查看字符串<br>
<img src="https://zyyiszyy.github.io/post-images/1617117638578.png" alt="" loading="lazy"><br>
双击字符串“you win”，x交叉引用进入引用字符串的代码区，tab键进入反编译的C语言代码，这里就是关键代码区：<br>
<img src="https://zyyiszyy.github.io/post-images/1617117674591.png" alt="" loading="lazy"><br>
这里很容易看到do循环里面的逻辑，把buf1中内容的依次异或一个数，这个数从0开始每次递增1。脚本如下：</p>
<pre><code>a=[81,48,84,77,82,64,72,82,90,103,126,114,110,63,55,125,93,69,95,60,65,127,84,71,86,43,110,81,74,94,88,38]
print(len(a))
b=0
for i in a:
    print(chr(i),end='')
print()
for i in a:
    print(chr(i^b),end='')
    b=b+1
</code></pre>
<p><img src="https://zyyiszyy.github.io/post-images/1617117705593.png" alt="" loading="lazy"><br>
突破点在这个函数，看懂它是base64加密就容易做了：<br>
<img src="https://zyyiszyy.github.io/post-images/1617118019047.png" alt="" loading="lazy"><br>
在线解码得到flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1617120994150.png" alt="" loading="lazy"></p>
<h1 id="fake">Fake</h1>
<p>查看文件语言，发现是.net编译成的exe，使用reflector反编译，获得源代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121065482.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1617121067735.png" alt="" loading="lazy"><br>
查看resource里面有个假flag，一会儿需要用到：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121103045.png" alt="" loading="lazy"><br>
大致逻辑是先让输入的flag和假flag进入加密函数，然后返回结果和second数组比较，相等就判断正确，这里主要逆向加密函数，关键在第三个循环用到了输入的flag，逆向的话用secend数组异或回去就可以了，脚本如下：</p>
<pre><code>flag=''
key='IS_THi5_r3al_FLAg?'
buffer=[0]*256
for i in range(256):
    buffer[i]=i
index=0
length=len(key)
for j in range(256):
    index=(index+buffer[j]+ord(key[j%length]))%256
    num=buffer[j]
    buffer[j]=buffer[index]
    buffer[index]=num
num0=0
index=0
item=[95,6,174,99,71,28,254,55,90,181,151,89,130,193,211,104,201,31,146,81,214,240,91,211,137,82,140,70,19,37]
for k in range(len(item)):
    num0=(num0+1)%256
    index=(index+buffer[num0])%256
    num1=buffer[num0]
    buffer[num0]=buffer[index]
    buffer[index]=num1
    flag+=chr(buffer[(buffer[num0]+buffer[index])%256]^item[k])
print(flag)    
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zyyiszyy.github.io/post-images/1617121130040.png" alt="" loading="lazy"></figure>
<h1 id="equation">Equation</h1>
<p>这道题用到了一个Ghidra反汇编工具，查看反汇编的代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121164508.png" alt="" loading="lazy"><br>
发现26个未知数，26个方程，使用z3py约束器求解，脚本如下：</p>
<pre><code>from z3 import *
a1=BitVec('a1',8)
a2=BitVec('a2',8)
a3=BitVec('a3',8)
a4=BitVec('a4',8)
a5=BitVec('a5',8)
a6=BitVec('a6',8)
a7=BitVec('a7',8)
a8=BitVec('a8',8)
a9=BitVec('a9',8)
a10=BitVec('a10',8)
a11=BitVec('a11',8)
a12=BitVec('a12',8)
a13=BitVec('a13',8)
a14=BitVec('a14',8)
a15=BitVec('a15',8)
a16=BitVec('a16',8)
a17=BitVec('a17',8)
a18=BitVec('a18',8)
a19=BitVec('a19',8)
a20=BitVec('a20',8)
a21=BitVec('a21',8)
a22=BitVec('a22',8)
a23=BitVec('a23',8)
a24=BitVec('a24',8)
a25=BitVec('a25',8)
a26=BitVec('a26',8)
s=Solver()
s.add(a26*0x1f4b+a25*0x97a+a24*0x891+a23*0x146e+a22*0x15d+a21*0x17dd+a20*0xccf+a19*0x1ec+a18*0x233c+a17*0x12b1+a16*0x1a85+a15*0x74a+a14*0x164e+a13*0x147e+a12*0x9f9+a11*0x51f+a10*0x20b4+a9*0x1126+a8*0x14cc+a7*0x254b+a6*0x1357+a5*0x11a7+a4*0x3d1+a3*0x445+a2*0x7e5+a1*0x260e==0xa13f2e)
s.add(a26*0x91a+a25*0x510+a24*0xcba+a23*0xcb5+a22*0x2296+a21*9000+a20*0x1f5e+a19*0x1f0+a18*0x1b6d+a17*0xa08+a16*0xfc3+a15*0x1e83+a14*0x6a2+a13*0x25ff+a12*0x218a+a11*0x10fe+a10*0x25f3+a9*0xb3a+a8*0x1bfd+a7*0x10d2+a6*0x1b98+a5*0x20cd+a4*0x2379+a3*0xf3b+a2*0x11bb+a1*0x164c==0xc94c86)
s.add(a26*0x246d+a25*0x8cb+a24*0x3bf+a23*0x207e+a22*0xfed+a21*0x78e+a20*0x270b+a19*0x38f+a18*0xebf+a17*0xe6b+a16*0x2486+a15*0x7a6+a14*0x5c5+a13*0x1bc0+a12*0x2397+a11*0x393+a10*0x239+a9*0x1399+a8*0x701+a7*0x2590+a6*0x984+a5*0x14ce+a4*0x438+a3*0x1715+a2*0x10b7+a1*0x26f1==0xa8ab81)
s.add(a26*0x1dd1+a25*0xdac+a24*0x1d33+a23*0x1fa7+a22*0x16c+a21*0x1d78+a20*0x2652+a19*0x1734+a18*0x1cb6+a17*0x19da+a16*0x12bb+a15*0x26c4+a14*0x1299+a13*0xc2f+a12*0x1b54+a11*0x1802+a10*0x1197+a9*0x1dbf+a8*0xd25+a7*0x1dc8+a6*0x1eab+a5*0x15a3+a4*0x1432+a3*0x11f2+a2*0x25bd+a1*0x159f==0xdcf5ed)
s.add(a26*0x2048+a25*0xb37+a24*0x1d3d+a23*0x15c2+a22*0x1d25+a21*0xd87+a20*0x4f6+a19*0x96b+a18*0x2545+a17*0x6a0+a16*0x90e+a15*0x1f57+a14*0x2379+a13*0xb63+a12*0x1c54+a11*0x6e+a10*0x16c1+a9*0x1dc8+a8*0x755+a7*0x49+a6*0x2e5+a5*0x1a91+a4*0x598+a3*0x1f7+a2*0x1839+a1*0x1423==0xa06d3c)
s.add(a26*0x1667+a25*0x243b+a24*0x1539+a23*0xa46+a22*0x60c+a21*0x105a+a20*0x912+a19*0x20de+a18*0x1534+a17*0xae4+a16*0xf7b+a15*0x1092+a14*0x1592+a13*0x2138+a12*0x8fb+a11*0x1665+a10*0x1ad2+a9*0x1681+a8*0xc93+a7*0x1a90+a6*0xf63+a5*0xe58+a4*0x15da+a3*0x8ef+a2*0x1b2a+a1*0xceb==0xb43671)
s.add(a26*0x1ef6+a25*0x201+a24*0xd35+a23*0x1a96+a22*0x59f+a21*0x615+a20*0xec+a19*0x217c+a18*0x1519+a17*0x7be+a16*0x1b8b+a15*0x1c79+a14*0x149+a13*0x239c+a12*0x1681+a11*0x1ed9+a10*0x1c1a+a9*0x1d35+a8*0xfc7+a7*0x1b94+a6*0x22+a5*0x959+a4*0x2e+a3*0x2096+a2*0x1c22+a1*0x10cc==0xaa4363)
s.add(a26*0xcda+a25*0x1727+a24*0x2083+a23*0x921+a22*0x17ac+a21*0x1ffe+a20*0x17ba+a19*0x25a4+a18*0xc27+a17*0x79f+a16*0x15d2+a15*0x1378+a14*0x21b+a13*0x18f9+a12*0x1faa+a11*0x932+a10*0x1964+a9*0x1937+a8*0x156e+a7*0x1933+a6*0x89f+a5*0x169d+a4*0x1df3+a3*0x9c+a2*0xd8d+a1*0x1336==0xb75629)
s.add(a26*0x8bb+a25*0x65d+a24*0x1596+a23*0x11d4+a22*0x9f1+a21*0x1869+a20*0x454+a19*0x1319+a18*0x2c8+a17*0xcc4+a16*0x1d8e+a15*0x1f9a+a14*0x1f73+a13*0x9fa+a12*0xfc6+a11*0x1180+a10*0x1c65+a9*0x4d0+a8*0x1e7+a7*0x1593+a6*0xd+a5*0x21dd+a4*0x2127+a3*0x21bd+a2*0x1432+a1*0x2c6==0x9e43ec)
s.add(a26*0xc34+a25*0x20c0+a24*0x2567+a23*0xf06+a22*0xcaa+a21*0x1cda+a20*0xfeb+a19*0x89b+a18*0x71c+a17*0x2263+a16*0x26e3+a15*0xded+a14*0x11a2+a13*0x377+a12*0x269c+a11*0x163e+a10*0xe9a+a9*0x13b4+a8*0x1597+a7*0x885+a6*0x764+a5*0xfe4+a4*0x23d0+a3*0x30d+a2*0x15bf+a1*0x22ad==0xb53898)
s.add(a26*0x16d5+a25*0x68c+a24*0x22e0+a23*0x150a+a22*0xfb2+a21*0x1f73+a20*0x2289+a19*0x8d6+a18*0x3a2+a17*0x1267+a16*0x2598+a15*0x2dc+a14*0xef2+a13*0x20bf+a12*900+a11*0x266+a10*0x16b8+a9*0xd91+a8*0xabc+a7*0x1e2c+a6*0x591+a5*0x466+a4*0x268e+a3*0x1a22+a2*0x61d+a1*0x286==0xa47644)
s.add(a26*0x206b+a25*0x139e+a24*0xded+a23*0x26bd+a22*0xfe0+a21*0x2a0+a20*0x1569+a19*0x14f8+a18*0x121b+a17*0xfc8+a16*0x14e7+a15*0x1716+a14*0x1ed8+a13*0x16d7+a12*0xc89+a11*0x1363+a10*0x489+a9*0x399+a8*0x96f+a7*0x8e8+a6*0xa79+a5*0x1156+a4*0x13bb+a3*0x138a+a2*0x15f5+a1*0x110a==0xa2cafd)
s.add(a26*0xb59+a25*0x2709+a24*0x1558+a23*0x1d80+a22*0xf16+a21*0x2524+a20*0xe6a+a19*0x1dc5+a18*0x5d+a17*0x700+a16*0x25a7+a15*0x238e+a14*0xe3b+a13*0x2509+a12*0x13fa+a11*0x1917+a10*0x241+a9*0x5c6+a8*0x97f+a7*0xe7d+a6*0x6d5+a5*0xbba+a4*0xa9a+a3*0x884+a2*0x1b24+a1*0x204a==0xaec682)
s.add(a26*0xfba+a25*0xde2+a24*0xd8b+a23*0x264d+a22*0x17d2+a21*0x1370+a20*0x823+a19*0xd94+a18*0x23be+a17*0x25d9+a16*0x484+a15*0x792+a14*0x14cb+a13*0x262+a12*0x25e+a11*0x8a5+a10*0x2646+a9*0x7be+a8*0x606+a7*0x22cd+a6*0x56a+a5*0xfae+a4*0x3f0+a3*0x1654+a2*0x10a9+a1*0xf69==0x9b5466)
s.add(a26*0x21ad+a25*0x1d7+a24*0x1854+a23*0x92c+a22*0x685+a21*0x1d7f+a20*0x1139+a19*0x1204+a18*0x191b+a17*0xfeb+a16*0x202+a15*0x10e4+a14*0x1bcd+a13*0x16d6+a12*0x1c59+a11*0x20b3+a10*0xb20+a9*0x1a43+a8*0x255c+a7*0x2174+a6*0x1765+a5*0x208e+a4*0x13d6+a3*0x4c6+a2*0x20ab+a1*0x17f7==0xc2b1b1)
s.add(a26*0x1803+a25*0x859+a24*0x1f1e+a23*0x14a6+a22*0x759+a21*0x1d00+a20*0x255a+a19*0x18f9+a18*0xe+a17*0x20fd+a16*0xbe3+a15*0x1d44+a14*0x220b+a13*0xb23+a12*0x15be+a11*0x25ef+a10*0x173e+a9*0x10db+a8*0x248d+a7*0xfb8+a6*0x2333+a5*0xfc4+a4*0x16e0+a3*0x1a38+a2*0x1c92+a1*0x1ffa==0xd173a5)
s.add(a26*0x26b8+a25*0xf8a+a24*0x1d23+a23*0x202+a22*0x3b2+a21*0x2077+a20*0x4d8+a19*0x23d5+a18*0x130+a17*0x1809+a16*0x16aa+a15*0x188+a14*0xcd7+a13*0x2055+a12*0x14ae+a11*0x2110+a10*0x2596+a9*0x1b20+a8*0x1ffb+a7*0xc6c+a6*0x24b2+a5*0xf3e+a4*0x1dcd+a3*0x176c+a2*0xe10+a1*0x229e==0xc4a065)
s.add(a26*0x7f5+a25*0xd09+a24*0x4e7+a23*0x1d91+a22*0xca0+a21*0x61d+a20*0x1264+a19*0x650+a18*0x825+a17*0xeb6+a16*0x14be+a15*0x24f7+a14*0x1965+a13*0x776+a12*0x206c+a11*0x13c4+a10*0x742+a9*0xa08+a8*0x1c73+a7*0x17c6+a6*0x8a4+a5*0xe14+a4*0x33e+a3*0x230+a2*0x11be+a1*0x245f==0x8e95b4)
s.add(a26*0x2050+a25*0x8f8+a24*0x2020+a23*0x1784+a22*0x1e10+a21*0x11dd+a20*0x2179+a19*0x1bf4+a18*0x11c6+a17*0x2244+a16*0x2334+a15*0x1dd5+a14*0x2614+a13*0x1149+a12*0x218c+a11*0xae5+a10*0x78a+a9*0x62+a8*0x6de+a7*0x238e+a6*0x12db+a5*0x57b+a4*0x19d8+a3*0x233+a2*0xf18+a1*0x774==0xc51ed8)
s.add(a26*0x1a67+a25*0x2491+a24*0xfc+a23*0x217c+a22*0x925+a21*0x1825+a20*0x1b2+a19*0x1691+a18*0x4f9+a17*0x1ea9+a16*0x151e+a15*0x15d4+a14*0x2f8+a13*0xf5e+a12*0x1ed2+a11*0x1d2a+a10*0xd58+a9*0x14cb+a8*0xe14+a7*0x2383+a6*0xeb0+a5*0xa29+a4*0x1432+a3*0x5f5+a2*0x1e4c+a1*0xa1a==0xabd395)
s.add(a26*0x9b9+a25*0x1ab0+a24*0x1030+a23*0x269b+a22*0x1cec+a21*0x246a+a20*0x1b04+a19*0x10ed+a18*0x56+a17*0x122a+a16*0x10e0+a15*0x72e+a14*0x16ee+a13*0x204a+a12*0xc6a+a11*0x941+a10*0x2471+a9*0xaea+a8*0x760+a7*0x171c+a6*0x1476+a5*0x364+a4*0x6ae+a3*0xc4+a2*0x1caf+a1*0x2313==0xac8c7f)
s.add(a26*0x1296+a25*0x2595+a24*0x1c92+a23*0x244f+a22*0x1b10+a21*0x209f+a20*0x263e+a19*0x228a+a18*0x1c67+a17*0x1fcc+a16*0x1533+a15*0x1373+a14*0x102b+a13*0x1a71+a12*0x11aa+a11*0x2565+a10*0xf43+a9*0x24f6+a8*0xc+a7*0xcfe+a6*0xa59+a5*0x10c6+a4*0x24aa+a3*0x1100+a2*0x10cf+a1*0x172e==0xe68ea2)
s.add(a26*0xf97+a25*0x111c+a24*0x1e86+a23*0xfff+a22*0x2031+a21*0x22fa+a20*0xb11+a19*0xf5b+a18*0xdd5+a17*0x2318+a16*0x1bd4+a15*0x143a+a14*0xc13+a13*0x81c+a12*0x1d62+a11*0x183b+a10*0xaac+a9*0x2368+a8*0xc5c+a7*0x2153+a6*0x2ac+a5*0xa0d+a4*0x1711+a3*0x2082+a2*0x1b1a+a1*0x13ae==0xc2b254)
s.add(a26*0x176a+a25*0x24bb+a24*0xe59+a23*3+a22*0x2058+a21*0x16c1+a20*0x53a+a19*0x6fe+a18*0x1e7c+a17*0x10c4+a16*0xa7+a15*0x26d6+a14*0xa4e+a13*0xc6d+a12*1099+a11*0x1773+a10*0x5ef+a9*0xf57+a8*0x1b54+a7*0x1148+a6*0x110b+a5*0xba0+a4*0x1136+a3*0x181e+a2*0x24ec+a1*0x17f0==0xa997a7)
s.add(a26*0x1f45+a25*0x3a+a24*0x1d19+a23*0x1521+a22*0xb76+a21*0x16c3+a20*0x1ac5+a19*0x18bd+a18*0x110f+a17*0xd0f+a16*0x1f49+a15*0x2165+a14*0x1da4+a13*0x53a+a12*0x449+a11*0x6be+a10*0xf83+a9*0xf9+a8*0x186d+a7*0x2354+a6*0x6cb+a5*0x1099+a4*0x24cb+a3*0x1451+a2*0x1ea2+a1*0x2002==0xb7a49e)
s.add(a26*0x41b+a25*0x17d7+a24*0x22db+a23*0x81d+a22*0xc16+a21*0x2165+a20*0x2387+a19*0x1860+a18*0x110e+a17*0x174e+a16*0x591+a15*0x2598+a14*0x26e0+a13*0x1a3b+a12*0xa8b+a11*0x387+a10*0xea3+a9*0x1a3a+a8*0x1537+a7*0x14c+a6*0x105+a5*0x4a8+a4*0x199f+a3*0x21bf+a2*0x1b90+a1*0x14c7==0xb6a3de)
if s.check()!=sat:
    print('no solusion!')
while s.check()==sat:
	print(chr(s.model()[a1].as_long()))
	print(chr(s.model()[a2].as_long()))
	print(chr(s.model()[a3].as_long()))
	print(chr(s.model()[a4].as_long()))
	print(chr(s.model()[a5].as_long()))
	print(chr(s.model()[a6].as_long()))
	print(chr(s.model()[a7].as_long()))
	print(chr(s.model()[a8].as_long()))
	print(chr(s.model()[a9].as_long()))
	print(chr(s.model()[a10].as_long()))
	print(chr(s.model()[a11].as_long()))
	print(chr(s.model()[a12].as_long()))
	print(chr(s.model()[a13].as_long()))
	print(chr(s.model()[a14].as_long()))
	print(chr(s.model()[a15].as_long()))
	print(chr(s.model()[a16].as_long()))
	print(chr(s.model()[a17].as_long()))
	print(chr(s.model()[a18].as_long()))
	print(chr(s.model()[a19].as_long()))
	print(chr(s.model()[a20].as_long()))
	print(chr(s.model()[a21].as_long()))
	print(chr(s.model()[a22].as_long()))
	print(chr(s.model()[a23].as_long()))
	print(chr(s.model()[a24].as_long()))
	print(chr(s.model()[a25].as_long()))
	print(chr(s.model()[a26].as_long()))
</code></pre>
<p><img src="https://zyyiszyy.github.io/post-images/1617121217846.png" alt="" loading="lazy"><br>
运行结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121239557.png" alt="" loading="lazy"></p>
<h1 id="dante">Dante</h1>
<p>先看了一下源代码，如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121262665.png" alt="" loading="lazy"><br>
大致就是前面一些操作给v12数组赋值，然后中间两个循环，外层循环200986次，内层循环35次，中间还用到了随机数随机数种子，种子和时间有关。这里的时间其实可以去掉，因为两个时间相减抵消掉，相当于每次内循环种子递增1，种子决定随机数的值。代码最后输出两串东西，这里猜测是输出flag。<br>
我的做法是改汇编代码，把时间函数去掉，让他递增一然后让他输出flag，改动的几个地方：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121338604.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1617121343493.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1617121346392.png" alt="" loading="lazy"><br>
看汇编可能看不懂什么，再看一下改动后反编译的C代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121369139.png" alt="" loading="lazy"><br>
直接将改后的程序运行，输出正确结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121391923.png" alt="" loading="lazy"></p>
<h1 id="debugme">Debugme</h1>
<p>这道题前一天晚上是upx壳，这次查壳没查到，估计是要手动脱壳，先打算ida找大跳转<br>
<img src="https://zyyiszyy.github.io/post-images/1617121427827.png" alt="" loading="lazy"><br>
失败了几次，干脆直接x64dbg运行看看，运行几步之后发现停在了一个地方<br>
<img src="https://zyyiszyy.github.io/post-images/1617121447847.png" alt="" loading="lazy"><br>
打算跳过去这个断点试试，突然想可能这下面就是解密后的，先dump下来，ida打开试试，打开字符串，发现原本不能用的交叉引用可以用了，进入输出提示要动调的函数，flag就在这里面。<br>
<img src="https://zyyiszyy.github.io/post-images/1617121471745.png" alt="" loading="lazy"><br>
后来发现这题目其实是有反动调的，可能并不是加了壳，因为一开始ida打开就显示函数，我的x64dbg自带反动调插件ScyllaHide，直接省事了，后面的异或其实正常做是动调过程看出来，我是dump出来用ida静态看出来的。解密脚本比较简单，如下：</p>
<pre><code>a=['27','1A','08','1F','08','11','09','1F','9','3E','19','38','03','05','1C','0F','2E','6F','0A','03','0F','35','03','6A','21','05','12','12','29','3A','03','05']
print(len(a))
for i in range(len(a)):
    a[i]='0x'+a[i]
    
for j in a:
    print(chr(int(j,16)^92),end='')
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zyyiszyy.github.io/post-images/1617121497088.png" alt="" loading="lazy"></figure>
<h1 id="pwn3">Pwn3</h1>
<p>直接用命令执行漏洞，用到了管道符||，如果前面执行出错则执行后面的语句，输入3||cat flag即获得flag。<br>
<img src="https://zyyiszyy.github.io/post-images/1617121528718.png" alt="" loading="lazy"></p>
<h1 id="easy_xor">Easy_XOR</h1>
<p>先base64解密密文：<br>
<img src="https://zyyiszyy.github.io/post-images/1617121559625.png" alt="" loading="lazy"><br>
再与BXS*10异或，前面不可打印字符可能网页转码有bug，这里取巧就直接先从后面的解密，加上flag头得到flag。脚本如下：</p>
<pre><code>a=&quot;#6#+* &lt;0y~;= /6!'&amp;.&quot;
key='BXS'*9+'B'
print(len(a))
for i in range(len(a)):
    print(chr(ord(a[i])^ord(key[i])),end='')
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://zyyiszyy.github.io/post-images/1617121583933.png" alt="" loading="lazy"></figure>
<h1 id="i-wanna-cumtctf">i wanna CUMTCTF</h1>
<p>本来想玩一下找找思路，结果直接玩出来的。<br>
<img src="https://zyyiszyy.github.io/post-images/1617121634610.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令执行、逻辑漏洞和暴力破解学习笔记]]></title>
        <id>https://zyyiszyy.github.io/post/ming-ling-zhi-xing-luo-ji-lou-dong-he-bao-li-po-jie-xue-xi-bi-ji/</id>
        <link href="https://zyyiszyy.github.io/post/ming-ling-zhi-xing-luo-ji-lou-dong-he-bao-li-po-jie-xue-xi-bi-ji/">
        </link>
        <updated>2021-03-20T09:08:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命令执行">命令执行</h1>
<h2 id="漏洞介绍">漏洞介绍</h2>
<p>应用程序有时要执行一些系统命令，这就需要一些调用系统命令的函数，如PHP中system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能够控制这些命令中的参数时，就可以将恶意的系统命令拼接到正常的系统命令中了，从而造成命令执行攻击。</p>
<h2 id="管道符介绍">管道符介绍</h2>
<p><strong>windows系统：</strong><br>
“|”：直接执行后面的语句。<br>
“||”：如果前面的执行出错，则执行后面的语句，前面的语句只能为假。如：ping 2||dir。<br>
“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。<br>
“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。<br>
<strong>linux系统：</strong><br>
“；”：执行完前面的再执行后面的。<br>
“|”：显示后面语句执行的结果。<br>
“||”：当前面的语句执行出错时，执行后面的语句。<br>
“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。<br>
“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的只能为真。</p>
<h2 id="修复建议">修复建议</h2>
<ul>
<li>尽量不要使用命令执行函数。</li>
<li>客户端提交的变量进入执行命令的函数前做好过滤和检查。</li>
<li>在使用动态函数前，确保使用的函数是指定的函数之一。</li>
<li>对php语言来说，不能完全控制的函数最好不要使用。</li>
</ul>
<h1 id="逻辑漏洞">逻辑漏洞</h1>
<h2 id="漏洞介绍-2">漏洞介绍</h2>
<p>逻辑漏洞就是利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付等功能处。黑客在挖掘逻辑漏洞的时候有两个重点：业务流程和HTTP/HTTPS请求篡改。</p>
<h2 id="越权访问介绍">越权访问介绍</h2>
<ul>
<li>水平越权：相同级别的用户或同一角色中不同的用户之间，可以越权访问、修改或删除其他用户的信息的非法操作。出现此漏洞往往会造成大批量数据泄露，严重的话会造成用户信息被恶意修改。</li>
<li>垂直越权：就是不同级别的用户或不同角色之间的用户的越权，如普通用户执行管理员才能执行的功能。</li>
</ul>
<h2 id="越权访问攻击防御">越权访问攻击防御</h2>
<p>攻击产生的主要原因是没有对用户身份做好判断和控制。可以增加session，用户登录成功后，将一些信息放入session中，当用户查看个人信息时，从session中取信息，而不是从get或post请求获取。</p>
<h1 id="暴力破解攻击">暴力破解攻击</h1>
<h2 id="攻击介绍">攻击介绍</h2>
<p>服务端没有做限制，导致攻击者可以通过暴力的手段破解所需的信息，如用户名、密码、验证码等。暴力破解的关键在于字典的大小。</p>
<h2 id="burpsuite四种攻击模式">burpsuite四种攻击模式</h2>
<p>Sniper：对变量依次进行破解，多个标记依次进行。<br>
battering ram：对变量同时进行破解，多个标记同时进行。<br>
pitchfork：每一个变量标记对应一个字典，取每个字典的对应项。<br>
cluster bomb：每个变量对应一个字典，并且进行交集破解，尝试各种组合。适用于用户名+密码的破解。</p>
<h2 id="dvwa攻击示例">DVWA攻击示例</h2>
<p><strong>low难度</strong><br>
burp在登录时抓包，然后发送到Intruder，在Position栏选中username和password作为payload：<br>
<img src="https://zyyiszyy.github.io/post-images/1616244030647.png" alt="" loading="lazy"><br>
然后在Payload栏设置字典，爆破管理员的密码，猜测username为root或者admin。<br>
<img src="https://zyyiszyy.github.io/post-images/1616244154077.png" alt="" loading="lazy"><br>
然后第二个payload设置字典为自带的password：<br>
<img src="https://zyyiszyy.github.io/post-images/1616244226383.png" alt="" loading="lazy"><br>
选择攻击模式为Cluster bomb，然后就可以开始暴力破解了，在length里找不一样的返回包，点击查看返回信息和登陆成功的返回页面：<br>
<img src="https://zyyiszyy.github.io/post-images/1616244334732.png" alt="" loading="lazy"></p>
<h2 id="修复建议-2">修复建议</h2>
<ul>
<li>设置用户登录次数的阈值，超过阈值锁定账号。</li>
<li>对某个ip设置登录次数的阈值，超过阈值封锁ip。<br>
其中第二个方法可能存在多个用户使用同一个ip，则会造成其他用户无法登录。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSRF和SSRF学习笔记]]></title>
        <id>https://zyyiszyy.github.io/post/csrf-he-ssrf-xue-xi-bi-ji/</id>
        <link href="https://zyyiszyy.github.io/post/csrf-he-ssrf-xue-xi-bi-ji/">
        </link>
        <updated>2021-03-19T13:08:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csrf漏洞">CSRF漏洞</h1>
<h2 id="漏洞介绍">漏洞介绍</h2>
<p>CSRF（Cross-site request forgery）跨站请求伪造，又叫做One Click Attack或者Session Riding，通常缩写为CSRF和XSRF，是一种对网站的恶意利用。其不太流行，所以防范资料较少，难以防范，被认为比XSS更有危险性。</p>
<h2 id="漏洞原理">漏洞原理</h2>
<p>攻击者利用目标用户的身份，以目标用户的名义执行一些非法操作，如：发送邮件、发消息、盗取目标用户的账号、购买物品、虚拟货币转账等。经常用来制作蠕虫病毒、刷SEO流量等。</p>
<h2 id="攻击条件">攻击条件</h2>
<ul>
<li>目标用户已经登录了某网站，能够执行网站的某些功能。</li>
<li>目标用访问了攻击者的URL。</li>
</ul>
<h2 id="dvwa题目练习">DVWA题目练习</h2>
<p><strong>low难度</strong><br>
先输入要改的密码，确认密码，然后点击change，这时抓包。<br>
<img src="https://zyyiszyy.github.io/post-images/1616166274066.png" alt="" loading="lazy"><br>
这里根据抓的包构造链接<code>http://127.0.0.1/DVWA-master/vulnerabilities/csrf/?password_current=password&amp;password_new=zyyire&amp;password_conf=zyyire&amp;Change=Change</code>因为假设用户已经登录这个网站，所以token不需要。再写一个html页面：<br>
<img src="https://zyyiszyy.github.io/post-images/1616166484815.png" alt="" loading="lazy"><br>
我把这个页面放在了博客里：<br>
<img src="https://zyyiszyy.github.io/post-images/1616166563446.png" alt="" loading="lazy"><br>
假设有人登录上了dvwa，这时又访问了我的博客，打开这个页面，又看到这个链接：<br>
<img src="https://zyyiszyy.github.io/post-images/1616167140737.png" alt="" loading="lazy"><br>
点击之后，显示密码已经更改：<br>
<img src="https://zyyiszyy.github.io/post-images/1616167181428.png" alt="" loading="lazy"><br>
或者在抓包的时候，右键点击Engagement Tools，然后点击Generate CSRF PoC，直接复制生成的HTML就可。<br>
<img src="https://zyyiszyy.github.io/post-images/1616167346312.png" alt="" loading="lazy"><br>
<strong>medium难度</strong><br>
增加了HTTP_Referer头的判断，目的是判断是否域名来自主机，但并不能验证是否来自同源的访问。可以改文件名137.0.0.1.html就可以绕过。<br>
<strong>hign难度</strong><br>
增加了token，是一个随机数，算是一种保护。这里要想办法获得目标的cookie，然后再获取其token，还涉及到跨域访问的问题。所以采用其他的方式获取token才能实施攻击。<br>
<strong>impossible难度</strong><br>
增加了旧密码的验证，增加了token验证，不知道旧密码根本无法攻击。</p>
<h2 id="防御措施">防御措施</h2>
<ul>
<li>验证请求的Referer值，如果其是以自己网站开头的域名，则可能请求来自于网站自己。若其域名是其他网站或者空白，就有可能是CSRF攻击，需要将请求过滤掉。</li>
<li>在请求中插入不能伪造的信息，如在HTTP请求中以参数形式加入一个随机的token，服务器端验证token正确性。</li>
</ul>
<h1 id="ssrf漏洞">SSRF漏洞</h1>
<h2 id="漏洞介绍-2">漏洞介绍</h2>
<p>SSRF（Server-Side Request Forgery）服务器端请求伪造，是一种由客户端伪造请求，由服务器端发起请求的漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<h2 id="漏洞原理-2">漏洞原理</h2>
<p>形成原因大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤和限制。如黑客操纵服务端从指定的URL地址获取网页的文本内容，加载指定地址的图片等。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地服务器。</p>
<h2 id="防御措施-2">防御措施</h2>
<ul>
<li>限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。</li>
<li>设置url白名单或限制不能访问内网的ip。</li>
<li>屏蔽返回的详细信息。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过XXE - PHP Audit Basic学习外部实体注入漏洞]]></title>
        <id>https://zyyiszyy.github.io/post/tong-guo-xxe-php-audit-basic-xue-xi-wai-bu-shi-ti-zhu-ru-lou-dong/</id>
        <link href="https://zyyiszyy.github.io/post/tong-guo-xxe-php-audit-basic-xue-xi-wai-bu-shi-ti-zhu-ru-lou-dong/">
        </link>
        <updated>2021-03-18T09:38:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xxe介绍">XXE介绍</h1>
<p>XXE全称<strong>XML外部实体注入漏洞（XML External Entity）</strong>，XML用于标记电子文件十七具有结构性的标记语言，主要负责数据传输和存储，相似的html主要用于显示。XML文档结构包括xml声明、<strong>DTD文档类型定义</strong>、文档元素。</p>
<h1 id="xxe漏洞的危害">XXE漏洞的危害：</h1>
<ul>
<li>读取系统文件</li>
<li>执行系统命令</li>
<li>探测内网端口</li>
<li>攻击内部网络</li>
</ul>
<h1 id="xml语法结构">XML语法结构：</h1>
<p>内部声明DTD格式：<!DOCTYPE 根元素 【元素声明】><br>
引用外部DTD格式：<!DOCTYPE 根元素 SYSTEM "文件名"><br>
内部声明实体格式：<!ENTITY 实体名称 "实体的值"><br>
引用外部实体格式：<!ENTITY 实体名称 SYSTEM "URI"></p>
<h1 id="xxe漏洞代码语句">XXE漏洞代码语句：</h1>
<pre><code>file_get_contents   //获取客户端输入内容
new DOMDocument()  //初始化XML解析器
loadXML($xmlfile)  //加载客户端输入的XML内容
simplexml_import_dom($dom)  //获取XML文档节点，成功则返回SimpleXMLElement对象，失败返回False
</code></pre>
<h1 id="xxe漏洞修复建议">XXE漏洞修复建议：</h1>
<ul>
<li>禁止使用外部实体，如：libxml_disable_entity_loader(true)。</li>
<li>过滤用户提交的XML数据。</li>
</ul>
<h1 id="xxe-php-audit-basic题目">XXE - PHP Audit Basic题目</h1>
<p>搭建环境Windows10</p>
<h2 id="domdocumentphp">DOMDocument.php</h2>
<h2 id="simplexmlelementphp">SimpleXMLElement.php</h2>
<h2 id="simplexml_load_stringphp">simplexml_load_string.php</h2>
<h2 id="blindxxephp">BlindXXE.php</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Upload-labs题目学习文件上传漏洞（1-11题）]]></title>
        <id>https://zyyiszyy.github.io/post/upload-labs-ti-mu-lian-xi-wen-jian-shang-chuan-lou-dong-1-6-ti/</id>
        <link href="https://zyyiszyy.github.io/post/upload-labs-ti-mu-lian-xi-wen-jian-shang-chuan-lou-dong-1-6-ti/">
        </link>
        <updated>2021-03-16T14:58:56.000Z</updated>
        <content type="html"><![CDATA[<p>**造成文件上传的原因：**服务端代码未对客户端上传的文件进行严格的验证和过滤，造成可以上传任意文件的情况，包括脚本文件asp、aspx、php、jsp等格式。<br>
<strong>文件上传修复建议：</strong></p>
<ul>
<li>通过白名单的方式判断文件是否合法。</li>
<li>对上传的文件进行重命名，如rand(10,99).date(&quot;YmdHis&quot;).&quot;.jpg&quot;。</li>
</ul>
<h1 id="关卡1-js检测绕过攻击">关卡1 JS检测绕过攻击</h1>
<p>这里已提交php文件就提示消息框：</p>
<figure data-type="image" tabindex="1"><img src="https://zyyiszyy.github.io/post-images/1615907146277.png" alt="" loading="lazy"></figure>
<p>判断是前端的验证，首先生成一句话木马文件，改名为webshell.png，然后上传，这时可以通过js验证。同时burpsuite抓包，在burpsuite里改文件后缀，发送文件即上传成功。<br>
另一种方法：直接禁止JS运行，火狐浏览器地址栏输入about:config，找到javascript.enabled，关闭选项，刷新页面，重新上传文件即可上传成功。</p>
<h1 id="关卡2-服务端对mime检查">关卡2 服务端对MIME检查</h1>
<p>查看源代码的判断：<br>
<img src="https://zyyiszyy.github.io/post-images/1615913754333.png" alt="" loading="lazy"><br>
属于文件类型绕过攻击，主要判断Content-Type的值，上传php文件时值为：application/octet-stream，上传jpg文件时的值为：image/jpeg。<br>
本题先上传php文件，抓包，然后将Content-Type改为image/jpeg，就可以绕过成功，通过返回信息查看文件路径进行下一步攻击。</p>
<h1 id="关卡3-文件后缀绕过攻击">关卡3 文件后缀绕过攻击</h1>
<p>这道题源码就只是过滤了四个类型，最后改文件名为随机数字：<br>
<img src="https://zyyiszyy.github.io/post-images/1615907719333.png" alt="" loading="lazy"><br>
将文件名依次改为php2 php3 php4 php5 phtml pht，上传成功，burpsuite里看文件路径和文件名。</p>
<h1 id="关卡4-htaccess文件绕过">关卡4 .htaccess文件绕过</h1>
<p>这次绕过了许多函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1615909304406.png" alt="" loading="lazy"><br>
但是没有绕过.htaccess，所以可以通过.htaccess绕过方式攻击。先建立文件，内容为：SetHandler applicationx-httpd-php。让所有的文件都解析为php,上传文件，再上传图片马。</p>
<h1 id="关卡5-php-和-windows环境的叠加特性绕过">关卡5 PHP 和 Windows环境的叠加特性绕过</h1>
<p>利用PHP 和 Windows环境的叠加特性，以下符号在正则匹配时的相等：<br>
‘&quot;’=‘.’;‘&gt;’=‘?’;‘&lt;’= ‘*’。<br>
首先借助burpsuite上传名为4.php:.jpg的空文件，解析后就成了名为4.php的空文件，再将一句话木马改名为“4.&lt;”，上传，然后内容便进入刚才的空文件里生成了4.php。上一题同样适用。</p>
<h1 id="关卡6-后缀大小写绕过">关卡6 后缀大小写绕过</h1>
<p>观察源代码，这道题没有进行大小写统一，所以可以进行大小写绕过。<br>
<img src="https://zyyiszyy.github.io/post-images/1615909612188.png" alt="" loading="lazy"><br>
更改文件名为shell.phP，上传文件即可成功绕过。</p>
<h1 id="关卡7-空格绕过">关卡7 空格绕过</h1>
<p>观察源代码，发现没用去掉空格：<br>
<img src="https://zyyiszyy.github.io/post-images/1615910745871.png" alt="" loading="lazy"><br>
所以可以进行空格绕过，在burpsuite中将文件名改为&quot;webshell.php &quot;并查看文件名和路径。</p>
<h1 id="关卡8-点绕过">关卡8 点绕过</h1>
<p>观察源代码，没有删除文件名后的点。<br>
<img src="https://zyyiszyy.github.io/post-images/1615911326907.png" alt="" loading="lazy"><br>
windows特性，会自动去掉后缀名中最后的”.”,所以改名为“shell.php.”。</p>
<h1 id="关卡9-data绕过">关卡9 ::$DATA绕过</h1>
<p>观察源代码，没有去除字符串<code>::$DATA</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615911947145.png" alt="" loading="lazy"><br>
在php+windows的情况下：如果文件名+<code>::$DATA</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，保持<code>::$DATA</code>之前的文件名。所以可以借助burpsuite在后缀名加<code>::$DATA</code>进行绕过。</p>
<h1 id="关卡10-点空格点绕过">关卡10 点+空格+点绕过</h1>
<p>保存文件的时候没有重命名而使用的原始的文件名，源代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615912732277.png" alt="" loading="lazy"><br>
将文件名通过burpsuite改为：”shell.php. .“,经过处理后变成：“shell.php.”，就能成功绕过。</p>
<h1 id="关卡11-双写绕过">关卡11 双写绕过</h1>
<p>如果后缀在黑名单里，就将其替换为空，也就是去掉，源代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615913399885.png" alt="" loading="lazy"><br>
所以可以将后缀写两层，文件名为：&quot;shell.pphphp&quot;。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQLMAP使用方法和常用命令]]></title>
        <id>https://zyyiszyy.github.io/post/sqlmap-shi-yong-fang-fa-he-chang-yong-ming-ling/</id>
        <link href="https://zyyiszyy.github.io/post/sqlmap-shi-yong-fang-fa-he-chang-yong-ming-ling/">
        </link>
        <updated>2021-03-15T14:18:45.000Z</updated>
        <content type="html"><![CDATA[<p>SQLMap是个自动化的SQL注入工具，主要功能扫描、发现并利用给定URL的SQL注入漏洞，功能强大，特查阅书本作此简记，方便今后查询。</p>
<h1 id="sqlmap入门">sqlmap入门</h1>
<h3 id="判断是否存在sql注入">判断是否存在sql注入</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1</code><br>
注：多个参数时url加“”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615818542642.png" alt="" loading="lazy"></p>
<h3 id="判断文本中请求是否存在注入">判断文本中请求是否存在注入</h3>
<p><code>sqlmap.py -r desktop/1.txt</code><br>
WEB数据包文件中加载HTTP请求，这样一般不设置其他参数。</p>
<h3 id="查询当前用户下所有数据库">查询当前用户下所有数据库</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --dbs</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819127081.png" alt="" loading="lazy"></p>
<h3 id="获取数据库的表名">获取数据库的表名</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security --tables</code><br>
注：-D是指定库名，不指定可以省略。<br>
<img src="https://zyyiszyy.github.io/post-images/1615819287665.png" alt="" loading="lazy"></p>
<h3 id="获取表中字段名">获取表中字段名</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security -T users --columns</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819377555.png" alt="" loading="lazy"></p>
<h3 id="获取字段内容">获取字段内容</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security -T users -C id,username,password --dump</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819498044.png" alt="" loading="lazy"></p>
<h3 id="获取数据库所有用户">获取数据库所有用户</h3>
<p>在当前用户有权读取包含所有用户的表的权限时，使用该命令可以列出所有管理用户。<br>
<code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --users</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819597242.png" alt="" loading="lazy"></p>
<h3 id="获取数据库用户的密码">获取数据库用户的密码</h3>
<p>在当前用户有读取包含用户密码的权限，使用该命令可以列出用户和hash值。<br>
<code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --passwords</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819906690.png" alt="" loading="lazy"></p>
<h3 id="获取当前网站数据库的名称">获取当前网站数据库的名称</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --current-db</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615820000712.png" alt="" loading="lazy"></p>
<h3 id="获取当前网站数据库的用户名称">获取当前网站数据库的用户名称</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --current-user</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615820071721.png" alt="" loading="lazy"></p>
<h1 id="sqlmap进阶">sqlmap进阶</h1>
<h3 id="探测等级">探测等级</h3>
<p>一共五个测试等级，默认是1，等级越高速度越慢。HTTP cookie在level为2时就会测试；HTTP User-Agent/Referer头在level为3时就会测试；当level为5时，自动破解cookie，XFF等头部注入。总之，不确定哪个Payload或参数为注入点时，为保证全面性，建议用高的level值。<br>
<code>--level 5</code></p>
<h3 id="当前用户是否为管理员权限">当前用户是否为管理员权限</h3>
<p><code>--is-dba</code></p>
<h3 id="列出数据库管理员角色">列出数据库管理员角色</h3>
<p>仅适用当前数据库为Oracle的时候，当前用户有权读取包含所有用户的表，用该命令可列举每个用户的角色，也可以用-U指定想看哪个用户的角色。<br>
<code>--roles</code></p>
<h3 id="http-referer头">HTTP Referer头</h3>
<p>sqlmap可以在请求中伪造HTTP中的referer，当level不小于3，会尝试对referer注入。可以用referer命令来欺骗。<br>
<code>--referer</code></p>
<h3 id="运行自定会sql语句">运行自定会sql语句</h3>
<p><code>--sql-shell</code></p>
<h3 id="运行任意操作系统命令">运行任意操作系统命令</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，如果数据库上传一个二进制库，包含用户自定义的函数sys_exec()和sys_eval()，那么创建的这两个函数就可以执行系统命令。<br>
<code>--os-cmd,--os-shell</code></p>
<h3 id="从数据库服务器中读取文件">从数据库服务器中读取文件</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。<br>
<code>--file-read</code></p>
<h3 id="上传文件到数据库服务器中">上传文件到数据库服务器中</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。<br>
<code>--file-write --file-dest</code></p>
<blockquote>
<p>SQLMap还自带绕过脚本tamper，其功能和上面介绍的部分进阶功能用之甚少，随着以后学习再做扩充。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA["玩玩破解"学习笔记]]></title>
        <id>https://zyyiszyy.github.io/post/wan-wan-po-jie-xue-xi-bi-ji/</id>
        <link href="https://zyyiszyy.github.io/post/wan-wan-po-jie-xue-xi-bi-ji/">
        </link>
        <updated>2021-03-09T14:12:48.000Z</updated>
        <content type="html"><![CDATA[<p>吾爱破解论坛大佬yyhd发布玩玩破解系列，让身为菜鸡的我受益匪浅，在此记录一些知识点，方便以后查阅。注意：这里面的示例不是通用的，加密解密是对抗的过程，所谓“魔高一尺，道高一丈”，加密的方法各种各样，这些示例有助于新手们的入门和练习。<br>
大佬帖子：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1358649">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1358649</a></p>
<h2 id="字符串能搜到错误提示">字符串能搜到错误提示</h2>
<p>首先用PEID查壳软件查壳，发现加了upx壳。</p>
<h4 id="脱壳后爆破">脱壳后爆破</h4>
<p><code>upx -d 文件</code><br>
脱壳后，OD打开，右键打开插件“中文搜索引擎”，选择智能搜索。双击错误提示，找到上面关键的一个跳转：<br>
<img src="https://zyyiszyy.github.io/post-images/1615299845142.png" alt="" loading="lazy"><br>
将je改为jne或者jmp，然后右键选择“复制到文件”，右键“保存文件”。<br>
测试爆破成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615300053036.png" alt="" loading="lazy"></p>
<h4 id="不脱壳直接爆破">不脱壳直接爆破</h4>
<p>直接OD打开，运行，然后ctrl+G跳转401000。这次原本不能用的中文搜索引擎就可以正常使用了。然后同样方式找到关键跳转，然后更改。这时不能直接复制到文件了，需要用到打补丁小工具Inline Patch，将对应的地址的字节码改掉，添加后生成即可。<br>
<img src="https://zyyiszyy.github.io/post-images/1615300510249.png" alt="" loading="lazy"></p>
<h2 id="字符串搜不到错误提示">字符串搜不到错误提示</h2>
<h4 id="下内存断点">下内存断点</h4>
<p>用常规的方法不能直接搜到字符串，但运行发现有错误提示，猜测加了一些什么防御字符串搜索的代码。这时，我们需要打开内存页面，右键查找，ASCII栏搜索“登陆失败”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303677016.png" alt="" loading="lazy"><br>
记下其地址，然后进入cpu界面，在内存板块搜索该地址。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303694151.png" alt="" loading="lazy"><br>
选中一段内存右键下内存访问断点。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303787318.png" alt="" loading="lazy"><br>
运行软件，输入错误数据，点击确定，这时就到达了断点。接下来删除断点，F8单步运行，每次专注ret之后的地方，找到以下可疑跳转：<br>
<img src="https://zyyiszyy.github.io/post-images/1615304360064.png" alt="" loading="lazy"><br>
很容易发现jmp直接跳过了这段代码，jmp下一句还有个跳过来的，经过短暂寻找，是在jmp上面代码跳过来的。意思大概是如果用户名密码正确就运行jmp这行代码，跳转输出“登录成功”；不正确就跳到jmp下面一行代码，输出“登陆失败”。<br>
此题直接将判断错误时的跳转nop掉就可：<br>
<img src="https://zyyiszyy.github.io/post-images/1615304650146.png" alt="" loading="lazy"></p>
<h4 id="下函数断点">下函数断点</h4>
<p>命令行输入bp MessageBoxA，然后运行，输入数据后到达断点，快捷键ctrl+F9进入CM领空，在右下角栈板块在“返回到”字样按回车，跳转到函数执行完的地方，本题第二个返回到就是关键代码处。<br>
<img src="https://zyyiszyy.github.io/post-images/1615306028838.png" alt="" loading="lazy"></p>
<h2 id="没有错误提示">没有错误提示</h2>
<p>之前思路是从结果反向找，这道题结果没有信息，只有成功时提示信息但是线索中断，所以正向找线索突破。</p>
<h4 id="下函数断点-2">下函数断点</h4>
<p>首先运行程序，输入内容但先不要点击登录，然后命令行下bp GetWindowTextA函数断点，点击登录。此时发现程序断的地方不在程序领空，所以按alt+F12，这以后就F8慢慢一步一步走，遇到别的领空就跳出来，知道运行到如下地方：<br>
<img src="https://zyyiszyy.github.io/post-images/1615454155791.png" alt="" loading="lazy"><br>
可以看到52010008等标志性字眼，这是易语言编写程序的窗口ID，可以理解为身份标号，这里就是弹出成功窗口的地方。本题将图示的关键跳转nop掉<br>
<img src="https://zyyiszyy.github.io/post-images/1615454453764.png" alt="" loading="lazy"><br>
爆破成功<br>
<img src="https://zyyiszyy.github.io/post-images/1615455068395.png" alt="" loading="lazy"></p>
<h4 id="易语言窗口替换">易语言窗口替换</h4>
<p>先查找命令push 10001，这里只有一个。<br>
<img src="https://zyyiszyy.github.io/post-images/1615476668879.png" alt="" loading="lazy"><br>
查找结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476691999.png" alt="" loading="lazy"><br>
这个52010008就是新的窗口id，也就是成功时弹出的那个窗口。再查找二进制字串<code>FF 25</code>，查找一开始的窗口的位置，发现一堆jmp：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476857686.png" alt="" loading="lazy"><br>
52010001就是一开始的窗口id，将其改为52010008，运行就是登录成功时的窗口：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476969720.png" alt="" loading="lazy"></p>
<h2 id="阶段性练习题目一">阶段性练习，题目一</h2>
<p>尝试了下内存断点，要么一直断要不不断，没成功。<br>
也尝试下MessageBoxA函数断点，没有断成功。</p>
<h4 id="窗口id替换">窗口id替换</h4>
<p>二进制搜索字串FF 25,找到初始的id，再输入命令push 10001查找成功和失败的id。这里是让成功和失败的id号互换，没有和初始的交换(不知为什么和初始窗口交换的话会失败，弹出来的窗口是空白)，输入假的用户名和密码，破解成功。<br>
<img src="https://zyyiszyy.github.io/post-images/1615552492149.png" alt="" loading="lazy"></p>
<h4 id="改关键跳转">改关键跳转</h4>
<p>通过搜push 10001找到关键代码，改掉关键跳转，如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615553791565.png" alt="" loading="lazy"></p>
<h4 id="下函数断点-3">下函数断点</h4>
<p>先运行，输入错误用户名和密码，先不点击按钮，下GetWindowTextA函数断点，再点击按钮，然后如果不是程序领空就alt+F9，是程序领空就F8单步调试，也能找到弹窗那个关键跳转。</p>
<h2 id="灰色按钮问题">灰色按钮问题</h2>
<h4 id="下函数断点-4">下函数断点</h4>
<p>命令行下bp EnableWindow断点，发现右下角栈的情况如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647119332.png" alt="" loading="lazy"><br>
这里动调我把false的0改为了1，运行就可以点击了，点击后如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647206039.png" alt="" loading="lazy"><br>
但是这个仅仅是动调，如果要破解这个软件，需要时刻都能点击，而不是每次都要动态调试。刚才已经发现false和按钮能不能点击有关系，false是函数传入的第一个参数。所以这次下断点后F8运行到返回：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647404635.png" alt="" loading="lazy"><br>
这里将第一个push改为push 1，每次传参数1，保存文件重新打开，这是发现破解成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647996889.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615648016686.png" alt="" loading="lazy"></p>
<h2 id="灰色按钮重启验证">灰色按钮+重启验证</h2>
<p>重启验证就是登录成功就在注册表或某个文件里记录信息，每次运行软件就会读信息验证是否正确，可以免于每次登录的麻烦，本题是记录到注册表里。</p>
<h4 id="针对按钮下函数断点">针对按钮下函数断点</h4>
<p>这个方法针对按钮，和注册表无关，方法同上。</p>
<h4 id="针对注册表下函数断点">针对注册表下函数断点</h4>
<p>这个方法是针对注册表的破解，程序先调用RegOpenKeyExA函数打开注册表里的一个项，再调用RegQueryValueExA函数读取这个项里面的键值，此处的函数是根据系统位数的不同而改变，不同的程序可能用的函数也不同。<br>
命令行下RegOpenKeyExA断点后运行程序，发现断点处栈区如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615650486155.png" alt="" loading="lazy"><br>
alt+F9运行到程序领空，代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615650541411.png" alt="" loading="lazy"><br>
F8返回几次，找到如下位置：<br>
<img src="https://zyyiszyy.github.io/post-images/1615652374029.png" alt="" loading="lazy"><br>
52pojie_yyhd是个关键点，就是验证注册表的，下面就是关键跳转，因为原来是跳转的，这里就nop掉不让他跳转。<br>
<img src="https://zyyiszyy.github.io/post-images/1615654401246.png" alt="" loading="lazy"><br>
破解成功，保存到文件再打开：<br>
<img src="https://zyyiszyy.github.io/post-images/1615654454606.png" alt="" loading="lazy"></p>
<h4 id="加注册表项">加注册表项</h4>
<p>上一方法找到关键词52pojie_yyhd，可以加到注册表项里，win+R搜索regedit，然后进入如下目录加入项和数值：<br>
<img src="https://zyyiszyy.github.io/post-images/1615655131809.png" alt="" loading="lazy"><br>
再打开程序，发现按钮可以用了：<br>
<img src="https://zyyiszyy.github.io/post-images/1615655189366.png" alt="" loading="lazy"><br>
注：为什么这个路径还不清楚，只知道如下信息，貌似如果是32位的操作系统，是“HKEY_LOCAL_MACHINE\SOFTWARE”如果是64位，在注册表就是“HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615655323966.png" alt="" loading="lazy"></p>
<h2 id="第一难-破解acid-burn">第一难 破解Acid burn</h2>
<h4 id="去nag">去NAG</h4>
<p><em>NAG窗口可以通过搜索窗口上的字符串或者对ShowWindow下断点，这里使用字符串搜索方法解决。</em><br>
搜索字符串找到如下位置：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728164755.png" alt="" loading="lazy"><br>
在此下断点，运行，然后F8运行到返回后如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728257803.png" alt="" loading="lazy"><br>
上面这个就是关键跳转，跳过这个call，条件跳转改为jmp即破解成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728325169.png" alt="" loading="lazy"><br>
另外一种下ShowWindow断点没做出来，倒是做下一步破解的时候下MessageBoxA断点找到了方法，具体见下一步。</p>
<h4 id="破解用户名密码登录">破解用户名密码登录</h4>
<p><em>搜字符串或者对MessageBoxA下断，F8到关键代码位置，这里使用搜字符串法解决。</em><br>
有两个判断，一个是输入不能少于4个字符，一个是判断是不是真码。<br>
搜索字符串有两个sorry，正好对应两个地方，分别下断点，一次输入少于4个字符，一次输入大于4个字符的假码，会断在两个地方，分别是：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728653006.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615728656943.png" alt="" loading="lazy"><br>
第一个把jge改为jmp，第二个把jnz给nop掉。<br>
<em>下函数断点</em><br>
命令bp MessageBoxA，然后运行程序，输入用户名密码，直到停在断点，这时断点在user.dll里，快捷键alt+F9转到程序领空，这时在一个call突然又断了：<br>
<img src="https://zyyiszyy.github.io/post-images/1615730634334.png" alt="" loading="lazy"><br>
检查发现时错误弹窗这时候弹出来了，关掉弹窗运行到CM领空。<br>
<img src="https://zyyiszyy.github.io/post-images/1615730739088.png" alt="" loading="lazy"><br>
这时找这个函数刚开始的push，如图，消息框里是从哪里调用过这个弹窗函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1615730846279.png" alt="" loading="lazy"><br>
右键消息框，一个一个返回到调用，其中有两个就是关键函数。另外：第一个去NAG消息框也能找到。</p>
<h4 id="破解密码登录">破解密码登录</h4>
<p>字符串法和MessageBoxA法两种同第二步。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Git遇到的一些问题]]></title>
        <id>https://zyyiszyy.github.io/post/xue-xi-git-de-yi-xie-jian-dan-shi-yong-fang-fa/</id>
        <link href="https://zyyiszyy.github.io/post/xue-xi-git-de-yi-xie-jian-dan-shi-yong-fang-fa/">
        </link>
        <updated>2021-03-08T14:48:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="git提交的步骤">git提交的步骤</h2>
<pre><code>git add .  //添加文件到本地仓库
git commit -m &quot;first commit&quot;  //添加描述信息
git remote add origin main  //连接远程仓库
git push -u origin main  //把本地仓库的文件推送到远程仓库
</code></pre>
<h2 id="提交出现以下错误">提交出现以下错误</h2>
<p><img src="https://zyyiszyy.github.io/post-images/1615219179296.png" alt="" loading="lazy"><br>
推送之前加入：<br>
<code>git pull origin main</code></p>
<h2 id="若还是失败提示以下错误">若还是失败，提示以下错误</h2>
<p><img src="https://zyyiszyy.github.io/post-images/1615219289494.png" alt="" loading="lazy"><br>
例如更新博客时，可尝试强制push：<br>
<code>git push -f origin main</code><br>
此方法不要随便用，因为强制push会覆盖掉远程的所有代码。</p>
<h2 id="初始使用git远程上传文件设置">初始使用git远程上传文件设置</h2>
<p>1、ssh-keygen -t rsa -C &quot;xxxxx@qq.com&quot;  //生成ssh密钥<br>
2、进文件id——rsa.pub，复制密钥到github<br>
3、ssh -T git@github.com   //检测是否配置成功，成功提示Hi xxxx......<br>
4、git config --global user.name &quot;username&quot;<br>
git config --global user.email &quot;xxxxx@qq.com&quot;     //配置信息<br>
5、git init   //git初始化<br>
6、git commit -m &quot;first commit&quot;   //添加描述信息<br>
7、git remote add origin git@github.com:zyyiszyy/zyyiszyy.github.io.git  //连接远程仓库，失败的话先 git remote rm origin<br>
8、git pull --rebase origin main  //拉取远程库<br>
9、git push -u origin main  //把本地仓库的文件推送到远程仓库<br>
10、若还是失败，考虑强制：git push -f origin main   用之前要慎重考虑！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接触CTF以来的闲散笔记]]></title>
        <id>https://zyyiszyy.github.io/post/idle_notes/</id>
        <link href="https://zyyiszyy.github.io/post/idle_notes/">
        </link>
        <updated>2021-03-07T08:03:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="re分析常用的api函数">re分析常用的API函数</h3>
<pre><code>对API函数下断点是一个普遍的破解真理。
GetWindowTextA //读取输入的内容
MessageBoxA  //弹信息窗
SendMessage //发送鼠标左键的消息函数
GetDlgItemInt //获取信息并转化为整数
Istrcmp  //整数字符串比较
SetWindowsTextA  //窗口名或组件出现已注册未注册字眼
EnableWindow  //解锁灰色按钮
RegOpenKeyExA  //打开注册表里的一个项(x32)
RegQueryValueExA  //读取这个项里面的键值(x32)
CreateToolhelp32Snapshot  //读取进程函数
ShowWindow  //调用NAG窗口的函数
filelength
GetFileSize
FindFirstFile   //都是获取文件的尺寸
</code></pre>
<h3 id="phpinfo">phpinfo</h3>
<pre><code>&lt;?php
phpinfo();
?&gt;
</code></pre>
<h3 id="易语言搜索按钮事件">易语言搜索按钮事件</h3>
<pre><code>先不点击按钮，查找二进制字串，搜索hex：FF55FC5F5E，下断点，点击按钮。
</code></pre>
<h3 id="易语言程序窗口id替换及其他知识点">易语言程序窗口ID替换及其他知识点</h3>
<pre><code>查找二进制字符串，搜索hex：FF 25
新窗口ID：520XXXXX
搜索其他窗口方法：可以查找命令push 10001。
</code></pre>
<h3 id="如何判断程序是否是易语言写的">如何判断程序是否是易语言写的</h3>
<pre><code>401000地址处汇编xor eax,eax就是，此方法不能百分百保证。
</code></pre>
<h3 id="dns刷新">dns刷新：</h3>
<pre><code>ipconfig /flushdns
</code></pre>
<h3 id="z3py约束求解">z3py约束求解：</h3>
<pre><code>先定义变量：a1=BitVec('a1',32)    a2=Int('a2')      #注意这里的变量类型是z3里的，不是python里的，要转化才可用
创建约束求解器：solver=Solver()                          #如果有位运算就要bitvec
添加约束条件：solver.add(a&gt;1)
判断解是否存在：if solver.check()==sat:   #不存在为unsat
输出解：print(solver.model())
取出解的某项的值：solver.model()[a1]
位变量bitvec转化python整数：solver.model()[a1].as_long()
约束可以逻辑运算：Or,And,Not
示例脚本有保存
</code></pre>
<h3 id="打开注册表命令">打开注册表命令</h3>
<pre><code>regedit
</code></pre>
<h3 id="一句话木马">一句话木马</h3>
<pre><code>&lt;?php @eval($_POST['cmd']) ?&gt;   //蚁剑连接
&lt;?php phpinfo();?&gt;
</code></pre>
<h3 id="浏览器关闭js服务">浏览器关闭JS服务</h3>
<pre><code>火狐为例，地址栏输入about:config，找到javascript.enabled，关闭选项，刷新页面。
</code></pre>
<h3 id="ropgadget或等rop链">ROPgadget或等rop链：</h3>
<pre><code>ROPgadget --binary 文件路径 --ropchain
</code></pre>
<h3 id="kali的checksec使用">kali的checksec使用：</h3>
<pre><code>checksec --file=文件路径
</code></pre>
<h3 id="ubuntu打开命令行">Ubuntu打开命令行：</h3>
<pre><code>ctrl+alt+T
</code></pre>
<h3 id="gdb的一些命令">gdb的一些命令：</h3>
<pre><code>r `python -c 'print &quot;A&quot;*'268 + &quot;B&quot;*4+&quot;C&quot;*4`
p/x $esp          查看esp寄存器的值
x/x $esp          查看寄存器的值并显示其地址
</code></pre>
<h3 id="python2里写中文">python2里写中文：</h3>
<pre><code>加上：#-*-coding:utf-8-*-
</code></pre>
<h3 id="usrbinpython">#!/usr/bin/python</h3>
<pre><code>脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它。
</code></pre>
<h3 id="提示xe6什么的错误">提示'\xe6'什么的错误：</h3>
<pre><code>脚本前面加：#_*_coding:utf8_*_
</code></pre>
<h3 id="查看各个端口和对应使用的进程uid">查看各个端口和对应使用的进程uid：</h3>
<pre><code>netstat -ano
</code></pre>
<h3 id="字符串转字节">字符串转字节：</h3>
<pre><code>bytes(m,'utf-8')
str(m,'utf-8')
from Crypto.Util.number import *
long_to_bytes(m)
</code></pre>
<h3 id="python反编译">python反编译：</h3>
<pre><code>uncompyle6是一个原生python的跨版本反编译器和fragment反编译器
uncompyle6 -o babypy.py babypy.pyc
</code></pre>
<h3 id="python编译">python编译：</h3>
<pre><code>&gt;&gt;&gt; import py_compile
&gt;&gt;&gt; py_compile.compile(r'/Users/zhangyi/Downloads/md5.py')
</code></pre>
<h3 id="kali更改时间">kali更改时间：</h3>
<pre><code>while true; do date -us &quot;2018-01-01 00:00:00&quot;;done
</code></pre>
<h3 id="python相关">python相关：</h3>
<pre><code>不能直接float变16进制，pwntools的p64里只能放16进制，可以用在线工具或写脚本。
</code></pre>
<h3 id="python写字符串依次遍历">python写字符串依次遍历：</h3>
<pre><code>a=‘ada’，b='',for i in range(len(a)):****
</code></pre>
<h3 id="竖列变行">竖列变行：</h3>
<pre><code>选择abc所在的三行，按Ctrl+H（编辑菜单，替换），将 ^p 替换为 &quot; &quot;。
</code></pre>
<h3 id="upx脱壳">upx脱壳：</h3>
<pre><code>cmd运行upx.exe -d 目标路径
</code></pre>
<h3 id="ord是ascii变为数字">ord是ASCII变为数字，</h3>
<pre><code>chr数字变ASCII字符
</code></pre>
<h3 id="jar文件为java可执行文件">.jar文件为java可执行文件：</h3>
<pre><code>打开jar文件方式：cmd：Java -jar 目标路径
</code></pre>
<h3 id="vim各个模式切换">vim各个模式切换：</h3>
<pre><code>i进入编辑模式，esc退出编辑模式进入一般命令模式，：进入命令行模式。wq！保存并退出。
</code></pre>
<h3 id="在kali写c代码">在kali写C代码：</h3>
<pre><code>建立文本.c文件名。命令：gcc test.c编译，在默认目录里生成a.out文件，运行就是代码运行结果。
</code></pre>
<h3 id="随机数注意事项">随机数注意事项：</h3>
<pre><code>windows和linux环境下相同种子伪随机数生成是不同的。
</code></pre>
<h3 id="c保留两位小数输出">C++保留两位小数输出：</h3>
<pre><code>#include &lt;iomanip&gt;   cout &lt;&lt; &quot;a=&quot; &lt;&lt;fixed&lt;&lt; setprecision(2) &lt;&lt; a &lt;&lt;endl; //输出结果为a=0.20
</code></pre>
<h3 id="c排序函数和逆向输出字符串">C++排序函数和逆向输出（字符串）：</h3>
<pre><code>reverse(remain.begin(),remain.end());
sort（a,a+n）;
</code></pre>
<h3 id="c获取数组的长度">C++获取数组的长度：</h3>
<pre><code>len=sizeof(a)/sizeof(a[0])；
</code></pre>
<h3 id="很多aaabbb有关的密码">很多AAABBB有关的密码：</h3>
<pre><code>培根密码：5个一组。摩斯密码:  .-  组成
</code></pre>
<h3 id="rar块的开头">rar块的开头：</h3>
<pre><code>文件块0x74
</code></pre>
<h3 id="密码种类有很多">密码种类有很多：</h3>
<pre><code>MD5，base64，培根密码，摩斯密码，栅栏密码(W型和传统型)，
</code></pre>
<h3 id="常见文件的文件头">常见文件的文件头：</h3>
<pre><code>https://blog.csdn.net/weixin_44604541/article/details/110082054
</code></pre>
<h3 id="rot13在线解密">Rot13在线解密：</h3>
<pre><code>https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html
</code></pre>
<h3 id="md5在线解密">md5在线解密：</h3>
<pre><code>https://www.somd5.com/
</code></pre>
<h3 id="base64在线解码">base64在线解码：</h3>
<pre><code>https://www.sojson.com/base64.html
</code></pre>
<h3 id="pdf转word">pdf转word：</h3>
<pre><code>https://app.xunjiepdf.com/pdf2word/
</code></pre>
<h3 id="mosi密码">mosi密码：</h3>
<pre><code>http://moersima.00cha.net/
</code></pre>
<h3 id="培根密码">培根密码：</h3>
<pre><code>http://rumkin.com/tools/cipher/baconian.php
</code></pre>
<h3 id="栅栏密码w型">栅栏密码（W型）：</h3>
<pre><code>http://www.atoolbox.net/Tool.php?Id=777
</code></pre>
<h3 id="栅栏密码传统">栅栏密码（传统）：</h3>
<pre><code>http://www.atoolbox.net/Tool.php?Id=855
</code></pre>
]]></content>
    </entry>
</feed>